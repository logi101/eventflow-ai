---
phase: 02-reminder-types
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - eventflow-scaffold/functions/send-reminder.ts
autonomous: true

must_haves:
  truths:
    - "Event-end reminder sends after event concludes"
    - "3-month follow-up sends only if manager approved"
    - "6-month follow-up sends only if manager approved"
    - "Follow-up reminders check settings.reminder_follow_up_Xmo flag"
  artifacts:
    - path: "eventflow-scaffold/functions/send-reminder.ts"
      provides: "Event-end and follow-up reminder handlers"
      min_lines: 550
      exports: ["serve"]
  key_links:
    - from: "event_end handler"
      to: "events.end_date"
      via: "date comparison query"
      pattern: "\\.lte\\('end_date'"
    - from: "follow_up handlers"
      to: "events.settings"
      via: "approval flag check"
      pattern: "settings\\?\\.reminder_follow_up"
---

<objective>
Add event-end and follow-up reminder handlers to send-reminder Edge Function.

Purpose: Enable late-stage reminders (thank you after event, follow-ups at 3mo/6mo with approval).
Output: Updated send-reminder.ts with 3 new reminder type handlers deployed to Supabase.
</objective>

<execution_context>
@/Users/eliyawolfman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eliyawolfman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@eventflow-scaffold/functions/send-reminder.ts
@.planning/phases/02-reminder-types/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Add event_end, follow_up_3mo, follow_up_6mo handlers</name>
  <files>eventflow-scaffold/functions/send-reminder.ts</files>
  <action>
Modify send-reminder.ts to add 3 new type handlers for late-stage reminders.

**Step 1: Update ReminderJob interface:**
```typescript
interface ReminderJob {
  type: 'activation' | 'week_before' | 'day_before' | 'morning' | '15_min'
       | 'event_end' | 'follow_up_3mo' | 'follow_up_6mo'
}
```

**Step 2: Add event_end handler (after 15_min handler, before closing brace):**
```typescript
if (type === 'event_end') {
  // Find events that ended (end_date passed) and are active/completed
  const { data: events } = await supabase
    .from('events')
    .select(`
      id, name, end_date, organization_id,
      settings,
      participants (
        id, first_name, phone_normalized, status
      )
    `)
    .lte('end_date', now.toISOString())
    .in('status', ['active', 'completed'])

  if (events) {
    for (const event of events) {
      if (!event.settings?.reminder_event_end) continue

      for (const participant of event.participants || []) {
        if (participant.status !== 'confirmed' && participant.status !== 'checked_in') continue

        results.processed++

        // Check if event-end reminder already sent
        const { data: existingMsg } = await supabase
          .from('messages')
          .select('id')
          .eq('event_id', event.id)
          .eq('participant_id', participant.id)
          .eq('type', 'reminder_event_end')
          .maybeSingle()

        if (existingMsg) continue

        const message = buildEventEndMessage(event, participant)

        const { data: msgData, error: msgError } = await supabase
          .from('messages')
          .insert({
            event_id: event.id,
            participant_id: participant.id,
            type: 'reminder_event_end',
            channel: 'whatsapp',
            recipient_name: participant.first_name,
            recipient_phone: participant.phone_normalized,
            content: message,
            status: 'pending',
          })
          .select()
          .maybeSingle()

        if (msgError || !msgData) {
          results.errors++
          continue
        }

        const sendResult = await sendWhatsApp(
          supabase,
          event.organization_id,
          participant.phone_normalized,
          message,
          msgData.id
        )

        if (sendResult.success) results.sent++
        else results.errors++
      }
    }
  }
}
```

**Step 3: Add follow_up_3mo handler:**
```typescript
if (type === 'follow_up_3mo') {
  // Find events completed ~90 days ago (88-92 day window)
  const days90ago = new Date(now)
  days90ago.setDate(days90ago.getDate() - 92)

  const days88ago = new Date(now)
  days88ago.setDate(days88ago.getDate() - 88)

  const { data: events } = await supabase
    .from('events')
    .select(`
      id, name, end_date, organization_id,
      settings,
      participants (
        id, first_name, phone_normalized, status
      )
    `)
    .gte('end_date', days90ago.toISOString())
    .lte('end_date', days88ago.toISOString())
    .eq('status', 'completed')

  if (events) {
    for (const event of events) {
      // CRITICAL: Check manager approval flag
      if (!event.settings?.reminder_follow_up_3mo) continue

      for (const participant of event.participants || []) {
        if (participant.status !== 'confirmed' && participant.status !== 'checked_in') continue

        results.processed++

        const { data: existingMsg } = await supabase
          .from('messages')
          .select('id')
          .eq('event_id', event.id)
          .eq('participant_id', participant.id)
          .eq('type', 'reminder_follow_up_3mo')
          .maybeSingle()

        if (existingMsg) continue

        const message = buildFollowUp3moMessage(event, participant)

        const { data: msgData, error: msgError } = await supabase
          .from('messages')
          .insert({
            event_id: event.id,
            participant_id: participant.id,
            type: 'reminder_follow_up_3mo',
            channel: 'whatsapp',
            recipient_name: participant.first_name,
            recipient_phone: participant.phone_normalized,
            content: message,
            status: 'pending',
          })
          .select()
          .maybeSingle()

        if (msgError || !msgData) {
          results.errors++
          continue
        }

        const sendResult = await sendWhatsApp(
          supabase,
          event.organization_id,
          participant.phone_normalized,
          message,
          msgData.id
        )

        if (sendResult.success) results.sent++
        else results.errors++
      }
    }
  }
}
```

**Step 4: Add follow_up_6mo handler:**
```typescript
if (type === 'follow_up_6mo') {
  // Find events completed ~180 days ago (178-182 day window)
  const days180ago = new Date(now)
  days180ago.setDate(days180ago.getDate() - 182)

  const days178ago = new Date(now)
  days178ago.setDate(days178ago.getDate() - 178)

  const { data: events } = await supabase
    .from('events')
    .select(`
      id, name, end_date, organization_id,
      settings,
      participants (
        id, first_name, phone_normalized, status
      )
    `)
    .gte('end_date', days180ago.toISOString())
    .lte('end_date', days178ago.toISOString())
    .eq('status', 'completed')

  if (events) {
    for (const event of events) {
      // CRITICAL: Check manager approval flag
      if (!event.settings?.reminder_follow_up_6mo) continue

      for (const participant of event.participants || []) {
        if (participant.status !== 'confirmed' && participant.status !== 'checked_in') continue

        results.processed++

        const { data: existingMsg } = await supabase
          .from('messages')
          .select('id')
          .eq('event_id', event.id)
          .eq('participant_id', participant.id)
          .eq('type', 'reminder_follow_up_6mo')
          .maybeSingle()

        if (existingMsg) continue

        const message = buildFollowUp6moMessage(event, participant)

        const { data: msgData, error: msgError } = await supabase
          .from('messages')
          .insert({
            event_id: event.id,
            participant_id: participant.id,
            type: 'reminder_follow_up_6mo',
            channel: 'whatsapp',
            recipient_name: participant.first_name,
            recipient_phone: participant.phone_normalized,
            content: message,
            status: 'pending',
          })
          .select()
          .maybeSingle()

        if (msgError || !msgData) {
          results.errors++
          continue
        }

        const sendResult = await sendWhatsApp(
          supabase,
          event.organization_id,
          participant.phone_normalized,
          message,
          msgData.id
        )

        if (sendResult.success) results.sent++
        else results.errors++
      }
    }
  }
}
```

**Step 5: Add message builder functions (after existing builders):**
```typescript
function buildEventEndMessage(event: any, participant: any): string {
  return `${participant.first_name} ×”×™×§×¨/×”, ğŸ™

×ª×•×“×” ×¨×‘×” ×¢×œ ×”×”×©×ª×ª×¤×•×ª ×‘-${event.name}!

× ×©××— ×œ×©××•×¢ ××” ×—×©×‘×ª ×¢×œ ×”××™×¨×•×¢ ğŸ’­
××©×•×‘ ×©×œ×š ×—×©×•×‘ ×œ× ×• ×•××©×¤×¨ ××ª ×”××™×¨×•×¢×™× ×”×‘××™×.

××§×•×•×™× ×œ×¨××•×ª×š ×‘××™×¨×•×¢×™× ×”×‘××™× ×©×œ× ×•! âœ¨`
}

function buildFollowUp3moMessage(event: any, participant: any): string {
  return `×©×œ×•× ${participant.first_name}! ğŸ‘‹

×¢×‘×¨×• 3 ×—×•×“×©×™× ×××– ${event.name}

××™×š ××ª×” ××¨×’×™×©/×”? ×”×× ×™×™×©××ª ××©×”×• ××”××™×¨×•×¢? ğŸŒ±

× ×©××— ×œ×©××•×¢ ××™×š ×”×œ×š ×œ×š ğŸ’¬`
}

function buildFollowUp6moMessage(event: any, participant: any): string {
  return `×”×™×™ ${participant.first_name}! ğŸŒŸ

×—×¦×™ ×©× ×” ×¢×‘×¨×” ×××– ${event.name}

× ×©××— ×œ×“×¢×ª ××” ×”×©×ª× ×” ×××– âœ¨
×™×© ×œ×š ××©×•×‘ ××• ×¨×¢×™×•× ×•×ª ×œ××™×¨×•×¢×™× ×”×‘××™×? ğŸ’¡

×ª××™×“ ×˜×•×‘ ×œ×©××•×¢ ×××š! ğŸ™‚`
}
```

**CRITICAL:**
- Follow-up handlers use 4-day window (not single day) - accommodates cron timing variance
- Both follow-up types check approval flag: `if (!event.settings?.reminder_follow_up_Xmo) continue`
- Event-end accepts both 'confirmed' and 'checked_in' statuses
- Follow-ups only for 'completed' events (not 'active')
  </action>
  <verify>
```bash
# 1. Syntax check
cd eventflow-scaffold/functions/send-reminder && deno cache index.ts

# 2. Deploy to Supabase (via MCP)

# 3. Test event_end (requires past event)
SELECT trigger_reminder_job('event_end');

# 4. Verify settings flag check for follow-ups
# Create test event with follow-up flags enabled
INSERT INTO events (organization_id, name, start_date, end_date, status, settings)
VALUES (
  (SELECT id FROM organizations LIMIT 1),
  'Test Follow-Up Event',
  NOW() - interval '91 days',
  NOW() - interval '91 days',
  'completed',
  jsonb_build_object('reminder_follow_up_3mo', true)
);

SELECT trigger_reminder_job('follow_up_3mo');
# Should process the test event

# Cleanup
DELETE FROM events WHERE name = 'Test Follow-Up Event';
```
  </verify>
  <done>
- send-reminder.ts includes event_end, follow_up_3mo, follow_up_6mo handlers
- ReminderJob interface updated with all 8 types
- Message builder functions added for 3 new types
- Approval flag checks working (follow-ups only send if settings.reminder_follow_up_Xmo = true)
- Event-end handler accepts completed/checked_in participants
- Follow-up handlers use 4-day date windows
  </done>
</task>

<task type="auto">
  <name>Deploy complete send-reminder function with all 8 types</name>
  <files>N/A (deployment operation)</files>
  <action>
Deploy the fully updated Edge Function:

```typescript
await mcp.deploy_edge_function({
  function_name: 'send-reminder',
  source_path: 'eventflow-scaffold/functions/send-reminder',
  verify_https: true
})
```

After deployment:
1. Verify function version (should be v7+)
2. Test all 3 new types via trigger_reminder_job
3. Check logs for runtime errors
4. Verify approval flags are respected

**Post-deployment smoke test:**
```sql
-- Test each new type
SELECT trigger_reminder_job('event_end');
SELECT trigger_reminder_job('follow_up_3mo');
SELECT trigger_reminder_job('follow_up_6mo');

-- Check results
SELECT type, count(*), max(created_at) as latest
FROM messages
WHERE type IN ('reminder_event_end', 'reminder_follow_up_3mo', 'reminder_follow_up_6mo')
GROUP BY type;
```
  </action>
  <verify>
```sql
-- Verify all 8 types are callable
SELECT
  trigger_reminder_job('activation'),
  trigger_reminder_job('week_before'),
  trigger_reminder_job('day_before'),
  trigger_reminder_job('morning'),
  trigger_reminder_job('15_min'),
  trigger_reminder_job('event_end'),
  trigger_reminder_job('follow_up_3mo'),
  trigger_reminder_job('follow_up_6mo');

-- Check no duplicate reminders created
SELECT event_id, participant_id, type, count(*)
FROM messages
WHERE type LIKE 'reminder_%'
GROUP BY event_id, participant_id, type
HAVING count(*) > 1;
-- Expected: 0 rows (no duplicates)
```
  </verify>
  <done>
- send-reminder Edge Function deployed with all 8 reminder types
- All types callable via trigger_reminder_job
- Approval flags for follow-ups working correctly
- No duplicate reminders detected
- Function logs show no runtime errors
  </done>
</task>

</tasks>

<verification>
Test full lifecycle:
1. All 8 types executable via trigger_reminder_job
2. Event-end reminder sends after event.end_date passes
3. Follow-up reminders only send if approval flag = true
4. No duplicate reminders for same (event, participant, type)
</verification>

<success_criteria>
- [ ] send-reminder.ts includes all 8 reminder type handlers
- [ ] ReminderJob interface lists all 8 types
- [ ] Message builders for event_end, follow_up_3mo, follow_up_6mo exist
- [ ] Edge Function deployed successfully (v7+)
- [ ] All 8 types callable via trigger_reminder_job without errors
- [ ] Follow-up reminders respect approval flags (verified via test)
- [ ] Event-end reminder uses correct date comparison
- [ ] Follow-ups use 4-day windows (88-92 days, 178-182 days)
</success_criteria>

<output>
After completion, create `.planning/phases/02-reminder-types/02-03-SUMMARY.md` documenting:
- Code changes made (3 new handlers)
- Deployment version
- Test results for all 3 new types
- Approval flag behavior verified
</output>
