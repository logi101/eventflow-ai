---
phase: 03-dynamic-template-system
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - eventflow-scaffold/functions/send-reminder.ts
autonomous: true

must_haves:
  truths:
    - "send-reminder fetches template from message_templates before building message"
    - "Variable substitution replaces {{participant_name}}, {{event_name}}, {{event_date}}, {{event_time}}, {{event_location}} with real values"
    - "Schedule-level variables ({{session_title}}, {{session_location}}, etc.) work for 15-min reminders"
    - "If template not found in DB, hardcoded builder function is used as fallback"
    - "All 8 reminder types use template-first approach"
    - "Templates render correctly with Hebrew RTL formatting"
  artifacts:
    - path: "eventflow-scaffold/functions/send-reminder.ts"
      provides: "Updated Edge Function with template fetching + variable substitution"
    - path: "Supabase deployed Edge Function send-reminder v7"
      provides: "Live Edge Function with dynamic template system"
  key_links:
    - from: "send-reminder handler (each type)"
      to: "message_templates table"
      via: "getMessageTemplate() query"
      pattern: "getMessageTemplate.*supabase.*message_type"
    - from: "getMessageTemplate()"
      to: "substituteVariables()"
      via: "template content passed to substitution"
      pattern: "substituteVariables.*template.*variables"
    - from: "substituteVariables()"
      to: "buildEventVariableMap() / buildScheduleVariableMap()"
      via: "variable map provides substitution values"
      pattern: "buildEventVariableMap|buildScheduleVariableMap"
---

<objective>
Modify send-reminder Edge Function to fetch templates from message_templates table, apply variable substitution, and fall back to hardcoded builders when templates are missing.

Purpose: This wires the template system into the live reminder pipeline, making messages configurable without code changes.
Output: Updated send-reminder Edge Function (v7) deployed to Supabase with template-first message building.
</objective>

<execution_context>
@/Users/eliyawolfman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eliyawolfman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-dynamic-template-system/03-RESEARCH.md
@.planning/phases/03-dynamic-template-system/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add template functions and wire all 8 handlers to use templates</name>
  <files>eventflow-scaffold/functions/send-reminder.ts</files>
  <action>
First, read the DEPLOYED Edge Function via MCP `get_edge_function` (project: byhohetafnhlakqbydbj, slug: send-reminder) to get the current v6 code. The local file at eventflow-scaffold/functions/send-reminder.ts is outdated (v1). Always use the deployed version as the base.

Add three new utility functions BEFORE the message builder functions:

**1. `getMessageTemplate(supabase, organizationId, messageType)` -> Promise&lt;string | null&gt;**

Fetches template content from message_templates table with org-specific override + system fallback:

```typescript
async function getMessageTemplate(
  supabase: any,
  organizationId: string,
  messageType: string
): Promise<string | null> {
  try {
    // Try org-specific template first
    const { data: orgTemplate } = await supabase
      .from('message_templates')
      .select('content')
      .eq('organization_id', organizationId)
      .eq('message_type', messageType)
      .eq('is_active', true)
      .maybeSingle()

    if (orgTemplate?.content) return orgTemplate.content

    // Fall back to system template
    const { data: sysTemplate } = await supabase
      .from('message_templates')
      .select('content')
      .is('organization_id', null)
      .eq('message_type', messageType)
      .eq('is_active', true)
      .eq('is_system', true)
      .maybeSingle()

    return sysTemplate?.content || null
  } catch (error) {
    console.error(`Template fetch error for ${messageType}:`, error)
    return null  // Fallback to hardcoded
  }
}
```

CRITICAL: Use `.is('organization_id', null)` for the system template query (NOT `.eq('organization_id', null)` — Supabase/PostgREST requires `.is()` for NULL comparisons).

CRITICAL: Use `message_type` column (NOT `type`). The message_templates table column is `message_type`.

**2. `substituteVariables(template, variables)` -> string**

```typescript
function substituteVariables(
  template: string,
  variables: Record<string, string>
): string {
  return Object.entries(variables).reduce(
    (result, [key, value]) => {
      return result.replace(
        new RegExp(`\\{\\{${key}\\}\\}`, 'g'),
        value || ''
      )
    },
    template
  )
}
```

**3. `buildEventVariableMap(event, participant)` -> Record&lt;string, string&gt;**

Uses the existing `formatDate()` and `formatTime()` helper functions already in the code:

```typescript
function buildEventVariableMap(event: any, participant: any): Record<string, string> {
  return {
    participant_name: participant.first_name || '',
    event_name: event.name || '',
    event_date: formatDate(event.start_date),
    event_time: formatTime(event.start_date),
    event_location: [event.venue_name, event.venue_address].filter(Boolean).join(' '),
  }
}
```

**4. `buildScheduleVariableMap(participant, schedule, roomInfo?)` -> Record&lt;string, string&gt;**

```typescript
function buildScheduleVariableMap(
  participant: any,
  schedule: any,
  roomInfo?: any
): Record<string, string> {
  return {
    participant_name: `${participant.first_name} ${participant.last_name || ''}`.trim(),
    session_title: schedule.title || '',
    session_location: schedule.location || '',
    session_room: roomInfo?.room_number || schedule.room || '',
    session_start_time: formatTime(schedule.start_time),
    session_end_time: formatTime(schedule.end_time),
    session_speaker: schedule.speaker_name || '',
  }
}
```

Then, modify EACH of the 8 handler blocks to use template-first approach.

For event-level handlers (activation, week_before, day_before, morning, event_end, follow_up_3mo, follow_up_6mo), apply this pattern:

BEFORE the participant loop starts (but inside the event loop), add template fetch:
```typescript
// Fetch template ONCE per event (not per participant)
const template = await getMessageTemplate(supabase, event.organization_id, 'reminder_activation')
```

Then replace the message building line:
```typescript
// OLD:
const message = buildActivationMessage(event, participant)

// NEW:
const message = template
  ? substituteVariables(template, buildEventVariableMap(event, participant))
  : buildActivationMessage(event, participant)
```

Apply the same pattern for all 7 event-level handlers, using the correct message_type for each:
- activation: `'reminder_activation'`
- week_before: `'reminder_week_before'`
- day_before: `'reminder_day_before'` (also handle companion message the same way)
- morning: `'reminder_morning'`
- event_end: `'reminder_event_end'`
- follow_up_3mo: `'reminder_follow_up_3mo'`
- follow_up_6mo: `'reminder_follow_up_6mo'`

For the 15-min handler, the pattern is different because it uses schedule data:

Inside the schedule loop (before participant_schedules loop), add:
```typescript
const template15 = await getMessageTemplate(supabase, schedule.events.organization_id, 'reminder_15min')
```

Then replace:
```typescript
// OLD:
const message = build15MinReminder(participant, schedule, roomInfo)

// NEW:
const message = template15
  ? substituteVariables(template15, buildScheduleVariableMap(participant, schedule, roomInfo))
  : build15MinReminder(participant, schedule, roomInfo)
```

For the day_before COMPANION message, also use template:
```typescript
const companionMessage = template
  ? substituteVariables(template, buildEventVariableMap(event, {
      first_name: participant.companion_name || 'אורח/ת',
    }))
  : buildDayBeforeMessage(event, {
      first_name: participant.companion_name || 'אורח/ת',
    })
```

IMPORTANT NOTES:
- Keep ALL existing hardcoded builder functions intact (they are the fallback)
- Keep ALL existing handler logic intact (queries, dedup checks, settings checks, message insert, sendWhatsApp)
- Only change the message building line in each handler
- Template fetch is per-event (cached for all participants in that event)
- For 15-min handler, template fetch is per-schedule

After modifying the local file, deploy via MCP `deploy_edge_function`:
- project_id: byhohetafnhlakqbydbj
- name: send-reminder
- entrypoint_path: index.ts
- verify_jwt: true
- files: [{name: "index.ts", content: <the full updated file content>}]
  </action>
  <verify>
1. Read the local file to confirm all 4 new functions exist: getMessageTemplate, substituteVariables, buildEventVariableMap, buildScheduleVariableMap

2. Verify via MCP `get_edge_function` that the deployed version includes the new functions

3. Grep the deployed code for these patterns:
   - `getMessageTemplate` appears 8+ times (once per handler)
   - `substituteVariables` appears 8+ times
   - `buildEventVariableMap` appears 7+ times (all event-level handlers)
   - `buildScheduleVariableMap` appears 1+ times (15-min handler)
   - All 8 original builder functions still exist (buildActivationMessage, buildWeekBeforeMessage, buildDayBeforeMessage, buildMorningMessage, build15MinReminder, buildEventEndMessage, buildFollowUp3moMessage, buildFollowUp6moMessage)
  </verify>
  <done>send-reminder Edge Function (v7) deployed with template-first message building for all 8 reminder types, with fallback to hardcoded builders.</done>
</task>

<task type="auto">
  <name>Task 2: Verify template rendering for all 8 types</name>
  <files>None (verification only)</files>
  <action>
Verify the full template system works end-to-end:

**1. SQL Verification — Templates exist and are queryable**

Run via execute_sql MCP:
```sql
SELECT message_type, name,
  length(content) as content_length,
  jsonb_array_length(variables) as var_count,
  content LIKE '%{{participant_name}}%' as has_participant_name
FROM message_templates
WHERE is_system = true
ORDER BY
  CASE message_type
    WHEN 'reminder_activation' THEN 1
    WHEN 'reminder_week_before' THEN 2
    WHEN 'reminder_day_before' THEN 3
    WHEN 'reminder_morning' THEN 4
    WHEN 'reminder_15min' THEN 5
    WHEN 'reminder_event_end' THEN 6
    WHEN 'reminder_follow_up_3mo' THEN 7
    WHEN 'reminder_follow_up_6mo' THEN 8
  END;
```
Expected: 8 rows, all has_participant_name=true.

**2. SQL Variable Substitution Sanity Check**

Run via execute_sql MCP:
```sql
SELECT message_type,
  replace(
    replace(
      replace(content, '{{participant_name}}', 'דני'),
      '{{event_name}}', 'כנס השנתי 2026'
    ),
    '{{event_date}}', 'יום שלישי, 15 בפברואר'
  ) as rendered_sample
FROM message_templates
WHERE is_system = true AND message_type = 'reminder_activation';
```
Expected: Hebrew text with "דני" and "כנס השנתי 2026" substituted, no remaining `{{` placeholders for those variables.

**3. Template Fetch Query Pattern Test**

Run via execute_sql MCP to simulate the exact query the Edge Function will use:
```sql
-- Simulate system template fetch (no org-specific template)
SELECT content
FROM message_templates
WHERE organization_id IS NULL
  AND message_type = 'reminder_activation'
  AND is_active = true
  AND is_system = true;
```
Expected: 1 row with activation template content.

**4. Edge Function Deployment Verification**

Read deployed function via get_edge_function MCP and confirm:
- `getMessageTemplate` function exists
- `substituteVariables` function exists
- `.is('organization_id', null)` used for NULL check (not `.eq`)
- `.eq('message_type',` used (not `.eq('type',`)
- All 8 handlers have `template ? substituteVariables(...)  : build...Message(...)` pattern
  </action>
  <verify>
All 4 verification checks pass:
1. 8 templates in DB with correct structure
2. Variable substitution produces readable Hebrew
3. Template fetch query returns exactly 1 row per type
4. Deployed Edge Function has template-first logic with fallback
  </verify>
  <done>Dynamic template system fully verified: templates seeded, Edge Function wired, variable substitution confirmed, fallback intact.</done>
</task>

</tasks>

<verification>
Phase 3 complete when ALL of these are true:

1. **TMPL-01**: send-reminder fetches templates from message_templates table
   - Verify: get_edge_function shows getMessageTemplate() called in each handler

2. **TMPL-02**: Variable substitution works for all variables
   - Verify: SQL substitution test produces clean Hebrew output
   - Variables: {{participant_name}}, {{event_name}}, {{event_date}}, {{event_time}}, {{event_location}}, {{session_title}}, {{session_location}}, {{session_room}}, {{session_start_time}}, {{session_end_time}}, {{session_speaker}}

3. **TMPL-03**: Each reminder type has a default template
   - Verify: `SELECT count(*) FROM message_templates WHERE is_system = true` = 8

4. **TMPL-04**: Templates support Hebrew RTL
   - Verify: Template content contains Hebrew characters and uses 'he-IL' locale for date/time formatting in buildEventVariableMap/buildScheduleVariableMap
</verification>

<success_criteria>
- send-reminder Edge Function deployed (v7) with template-first message building
- 8 system templates in message_templates table
- Variable substitution replaces all {{var}} placeholders with real values
- Fallback to hardcoded builders works when template is missing
- All existing functionality preserved (dedup, settings checks, companion messages)
</success_criteria>

<output>
After completion, create `.planning/phases/03-dynamic-template-system/03-02-SUMMARY.md`
</output>
