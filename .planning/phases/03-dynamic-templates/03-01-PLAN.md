---
phase: 03-dynamic-templates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - eventflow-scaffold/functions/send-reminder.ts
autonomous: true

must_haves:
  truths:
    - "send-reminder fetches templates from message_templates table by message_type"
    - "Variable substitution replaces {{participant_name}}, {{event_name}}, {{event_date}}, {{event_time}}, {{event_location}} with actual values"
    - "Missing variables resolve to empty string, not raw {{placeholder}}"
    - "Template not found falls back to hardcoded builder with console.warn"
    - "Templates fetched once per invocation and cached in Map"
  artifacts:
    - path: "eventflow-scaffold/functions/send-reminder.ts"
      provides: "Template engine integration with all 8 reminder handlers"
      exports: ["serve"]
  wiring:
    - from: "message_templates table"
      to: "substituteVariables function"
      via: "fetchTemplateBatch query"
    - from: "buildTemplateVariables"
      to: "substituteVariables"
      via: "Record<string, string> data object"
  key_links:
    - from: "reminder handler"
      to: "renderReminderMessage"
      via: "template engine call replacing buildXxxMessage()"
      pattern: "renderReminderMessage\\("
    - from: "fetchTemplateBatch"
      to: "message_templates"
      via: "supabase .from('message_templates')"
      pattern: "\\.from\\('message_templates'\\)"
    - from: "substituteVariables"
      to: "template content"
      via: "regex replace /\\{\\{(\\w+)\\}\\}/g"
      pattern: "/\\\\\\{\\\\\\{\\(\\\\w\\+\\)\\\\\\}\\\\\\}/g"
---

<objective>
Add template engine to send-reminder Edge Function and wire it into all 8 reminder handlers.

Purpose: Replace hardcoded message builders with dynamic template fetching from message_templates table, enabling runtime template editing without code deployment.
Output: Updated send-reminder.ts with template engine functions and all 8 handlers using dynamic template rendering with hardcoded fallback.
</objective>

<execution_context>
@/Users/eliyawolfman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eliyawolfman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-dynamic-templates/03-CONTEXT.md
@.planning/phases/03-dynamic-templates/03-RESEARCH.md
@eventflow-scaffold/functions/send-reminder.ts
@eventflow-app/supabase/migrations/20260128000002_seed_reminder_templates.sql
</context>

<tasks>

<task type="auto">
  <name>Add template engine functions to send-reminder.ts</name>
  <files>eventflow-scaffold/functions/send-reminder.ts</files>
  <action>
Add three template engine functions to send-reminder.ts. Place them BEFORE the existing hardcoded builder functions (before `buildDayBeforeMessage`).

**Function 1: substituteVariables**
```typescript
function substituteVariables(
  template: string,
  data: Record<string, string | null | undefined>
): string {
  return template.replace(/\{\{(\w+)\}\}/g, (_match, key) => {
    return data[key] ?? '';
  });
}
```

**Function 2: fetchTemplateBatch**
Fetches all active system templates in one query, returns Map keyed by message_type.
```typescript
async function fetchTemplateBatch(
  supabase: ReturnType<typeof createClient>
): Promise<Map<string, string>> {
  const { data: templates, error } = await supabase
    .from('message_templates')
    .select('message_type, content')
    .eq('is_active', true)
    .eq('is_system', true)
    .is('organization_id', null);

  if (error) {
    console.error('Failed to fetch templates:', error);
    return new Map();
  }

  const cache = new Map<string, string>();
  templates?.forEach((t: any) => cache.set(t.message_type, t.content));
  return cache;
}
```

**Function 3: buildTemplateVariables**
Builds the variable data object from event and participant data. Handles TWO cases:
- Event-level reminders (activation, week_before, day_before, morning, event_end, follow_up_3mo, follow_up_6mo): uses event + participant data
- Session-level reminders (15_min): uses schedule + participant data

```typescript
function buildEventTemplateVariables(event: any, participant: any): Record<string, string> {
  const eventDate = new Date(event.start_date);
  return {
    participant_name: participant.first_name || '',
    event_name: event.name || '',
    event_date: eventDate.toLocaleDateString('he-IL', {
      weekday: 'long',
      day: 'numeric',
      month: 'long'
    }),
    event_time: eventDate.toLocaleTimeString('he-IL', {
      hour: '2-digit',
      minute: '2-digit',
      timeZone: 'Asia/Jerusalem'
    }),
    event_location: [event.venue_name, event.venue_address].filter(Boolean).join(' ')
  };
}

function buildSessionTemplateVariables(schedule: any, participant: any): Record<string, string> {
  const startTime = new Date(schedule.start_time);
  const endTime = schedule.end_time ? new Date(schedule.end_time) : null;
  const timeOpts = { hour: '2-digit' as const, minute: '2-digit' as const, timeZone: 'Asia/Jerusalem' };

  return {
    participant_name: participant.first_name || '',
    participant_last_name: participant.last_name || '',
    session_title: schedule.title || '',
    session_start_time: startTime.toLocaleTimeString('he-IL', timeOpts),
    session_end_time: endTime ? endTime.toLocaleTimeString('he-IL', timeOpts) : '',
    session_location: schedule.location || '',
    session_room: schedule.room || '',
    session_speaker: schedule.speaker_name || ''
  };
}
```

**Function 4: renderReminderMessage (the orchestrator)**
```typescript
async function renderReminderMessage(
  templateCache: Map<string, string>,
  reminderType: string,
  variables: Record<string, string>,
  fallbackBuilder: () => string
): Promise<string> {
  const templateContent = templateCache.get(reminderType);

  if (!templateContent) {
    console.warn(`Template not found for ${reminderType}, using hardcoded fallback`);
    return fallbackBuilder();
  }

  return substituteVariables(templateContent, variables);
}
```

**IMPORTANT notes:**
- These functions go ABOVE the existing hardcoded builders (which are kept as fallback)
- `fetchTemplateBatch` is called ONCE at the start of the main handler, not per message
- `renderReminderMessage` takes a `fallbackBuilder` function reference so each handler can pass its existing builder
- Variable names MUST match exactly what the seeded templates use (see migration file): participant_name, event_name, event_date, event_time, event_location, participant_last_name, session_title, session_start_time, session_end_time, session_location, session_room, session_speaker
  </action>
  <verify>
Verify the four functions exist in send-reminder.ts:
```bash
grep -n "function substituteVariables" eventflow-scaffold/functions/send-reminder.ts
grep -n "function fetchTemplateBatch" eventflow-scaffold/functions/send-reminder.ts
grep -n "function buildEventTemplateVariables" eventflow-scaffold/functions/send-reminder.ts
grep -n "function buildSessionTemplateVariables" eventflow-scaffold/functions/send-reminder.ts
grep -n "function renderReminderMessage" eventflow-scaffold/functions/send-reminder.ts
```
All 5 functions should be found. Verify regex pattern is correct:
```bash
grep "\\\\{\\\\{" eventflow-scaffold/functions/send-reminder.ts
```
  </verify>
  <done>
- substituteVariables function added with /\{\{(\w+)\}\}/g regex and ?? fallback
- fetchTemplateBatch function added querying message_templates with is_active, is_system, organization_id IS NULL
- buildEventTemplateVariables and buildSessionTemplateVariables functions added with correct variable names
- renderReminderMessage orchestrator function added with fallback to hardcoded builder
- All existing hardcoded builders preserved as fallback
  </done>
</task>

<task type="auto">
  <name>Wire template engine into all 8 reminder handlers</name>
  <files>eventflow-scaffold/functions/send-reminder.ts</files>
  <action>
Modify the main serve() handler and all 8 reminder type blocks to use the template engine.

**Step 1: Fetch templates once at the start of the handler**

After `let results = { processed: 0, sent: 0, errors: 0 }` (or equivalent), add:

```typescript
// Fetch all templates once per invocation
const templateCache = await fetchTemplateBatch(supabase);
console.log(`Loaded ${templateCache.size} templates from database`);
```

**Step 2: Replace message building in EACH of the 8 handlers**

For each handler, replace the hardcoded `buildXxxMessage()` call with `renderReminderMessage()`.

**activation handler:**
Replace: `const message = buildActivationMessage(event, participant)`
With:
```typescript
const variables = buildEventTemplateVariables(event, participant);
const message = await renderReminderMessage(
  templateCache,
  'reminder_activation',
  variables,
  () => buildActivationMessage(event, participant)
);
```

**week_before handler:**
Replace: `const message = buildWeekBeforeMessage(event, participant)`
With:
```typescript
const variables = buildEventTemplateVariables(event, participant);
const message = await renderReminderMessage(
  templateCache,
  'reminder_week_before',
  variables,
  () => buildWeekBeforeMessage(event, participant)
);
```

**day_before handler:**
Replace: `const message = buildDayBeforeMessage(event, participant)`
With:
```typescript
const variables = buildEventTemplateVariables(event, participant);
const message = await renderReminderMessage(
  templateCache,
  'reminder_day_before',
  variables,
  () => buildDayBeforeMessage(event, participant)
);
```

Also replace the companion message building:
Replace: `const companionMessage = buildDayBeforeMessage(event, { first_name: participant.companion_name || ... })`
With:
```typescript
const companionVariables = buildEventTemplateVariables(event, {
  first_name: participant.companion_name || 'guest',
});
const companionMessage = await renderReminderMessage(
  templateCache,
  'reminder_day_before',
  companionVariables,
  () => buildDayBeforeMessage(event, { first_name: participant.companion_name || 'guest' })
);
```

**morning handler:**
Replace: `const message = buildMorningMessage(event, participant)`
With:
```typescript
const variables = buildEventTemplateVariables(event, participant);
const message = await renderReminderMessage(
  templateCache,
  'reminder_morning',
  variables,
  () => buildMorningMessage(event, participant)
);
```

**15_min handler:**
Replace the inline message string:
Replace: `` const message = `${ps.participants.first_name}, ... ` ``
With:
```typescript
const variables = buildSessionTemplateVariables(schedule, ps.participants);
const message = await renderReminderMessage(
  templateCache,
  'reminder_15min',
  variables,
  () => `${ps.participants.first_name}, ${'\u05d1\u05e2\u05d5\u05d3'} 15 ${'\u05d3\u05e7\u05d5\u05ea'}: ${schedule.title} ${'\ud83d\udccd'}${schedule.location || ''}`
);
```

**event_end handler:**
Replace: `const message = buildEventEndMessage(event, participant)`
With:
```typescript
const variables = buildEventTemplateVariables(event, participant);
const message = await renderReminderMessage(
  templateCache,
  'reminder_event_end',
  variables,
  () => buildEventEndMessage(event, participant)
);
```

**follow_up_3mo handler:**
Replace: `const message = buildFollowUp3moMessage(event, participant)`
With:
```typescript
const variables = buildEventTemplateVariables(event, participant);
const message = await renderReminderMessage(
  templateCache,
  'reminder_follow_up_3mo',
  variables,
  () => buildFollowUp3moMessage(event, participant)
);
```

**follow_up_6mo handler:**
Replace: `const message = buildFollowUp6moMessage(event, participant)`
With:
```typescript
const variables = buildEventTemplateVariables(event, participant);
const message = await renderReminderMessage(
  templateCache,
  'reminder_follow_up_6mo',
  variables,
  () => buildFollowUp6moMessage(event, participant)
);
```

**CRITICAL NOTES:**
- The `renderReminderMessage` is async so ALL calls must use `await`
- Template `message_type` values in DB use `reminder_` prefix (e.g., `reminder_activation`, `reminder_day_before`) -- match exactly
- Keep ALL existing hardcoded builder functions (buildDayBeforeMessage, buildMorningMessage, buildActivationMessage, etc.) -- they serve as fallback
- Do NOT change any query logic, deduplication checks, or message insertion logic -- only the message CONTENT generation changes
- The 15_min handler has a different data shape (schedule + participant_schedules) so it uses `buildSessionTemplateVariables` not `buildEventTemplateVariables`
  </action>
  <verify>
Verify all 8 handlers now use renderReminderMessage:
```bash
grep -c "renderReminderMessage" eventflow-scaffold/functions/send-reminder.ts
```
Expected: 9 (8 handlers + 1 companion message in day_before = 9 total calls)

Verify templateCache is fetched once:
```bash
grep -c "fetchTemplateBatch" eventflow-scaffold/functions/send-reminder.ts
```
Expected: 2 (1 function definition + 1 call in handler)

Verify all hardcoded builders still exist (kept as fallback):
```bash
grep -c "function build" eventflow-scaffold/functions/send-reminder.ts
```
Expected: at least 8 (buildDayBeforeMessage, buildMorningMessage, buildActivationMessage, buildWeekBeforeMessage, buildEventEndMessage, buildFollowUp3moMessage, buildFollowUp6moMessage, plus buildEventTemplateVariables and buildSessionTemplateVariables)

Verify no hardcoded builder is called directly (only via fallback):
```bash
grep -n "= buildDayBeforeMessage\|= buildMorningMessage\|= buildActivationMessage\|= buildWeekBeforeMessage\|= buildEventEndMessage\|= buildFollowUp3moMessage\|= buildFollowUp6moMessage" eventflow-scaffold/functions/send-reminder.ts
```
Expected: 0 direct calls (they should only appear inside arrow functions as fallback)
  </verify>
  <done>
- All 8 reminder handlers use renderReminderMessage with template engine
- templateCache fetched once via fetchTemplateBatch at handler start
- Each handler builds appropriate variables (event or session)
- Companion message in day_before also uses template engine
- All hardcoded builders preserved as fallback functions
- No direct calls to hardcoded builders outside of fallback arrow functions
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full integration:

1. Template engine functions exist:
```bash
grep -n "function substituteVariables\|function fetchTemplateBatch\|function buildEventTemplateVariables\|function buildSessionTemplateVariables\|function renderReminderMessage" eventflow-scaffold/functions/send-reminder.ts
```

2. All handlers wired:
```bash
grep -c "renderReminderMessage" eventflow-scaffold/functions/send-reminder.ts
# Expected: 9+ (8 handlers + companion)
```

3. Single fetch:
```bash
grep -n "fetchTemplateBatch(supabase)" eventflow-scaffold/functions/send-reminder.ts
# Expected: exactly 1 call site
```

4. Fallback preserved:
```bash
grep -c "Using hardcoded fallback" eventflow-scaffold/functions/send-reminder.ts
# Expected: 1 (in renderReminderMessage)
```
</verification>

<success_criteria>
- [ ] substituteVariables function handles {{var}} replacement with ?? fallback
- [ ] fetchTemplateBatch queries message_templates once per invocation
- [ ] buildEventTemplateVariables maps event/participant data to template variable names
- [ ] buildSessionTemplateVariables maps schedule/participant data to session template variables
- [ ] renderReminderMessage orchestrates fetch + substitute with hardcoded fallback
- [ ] All 8 handlers (activation, week_before, day_before, morning, 15_min, event_end, follow_up_3mo, follow_up_6mo) use renderReminderMessage
- [ ] Companion message in day_before handler also uses template engine
- [ ] Hardcoded builder functions preserved (not deleted)
- [ ] No direct calls to hardcoded builders outside fallback arrows
</success_criteria>

<output>
After completion, create `.planning/phases/03-dynamic-templates/03-01-SUMMARY.md` documenting:
- Template engine functions added
- Handlers wired (list all 8)
- Variable mapping (event vs session)
- Fallback strategy (hardcoded builders preserved)
- Lines changed / function count
</output>
