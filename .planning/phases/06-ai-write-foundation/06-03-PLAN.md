---
phase: 06-ai-write-foundation
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - eventflow-app/supabase/functions/execute-ai-action/index.ts
autonomous: true

must_haves:
  truths:
    - "Approved AI actions are executed via authenticated Edge Function using user JWT"
    - "RLS policies are enforced during execution (multi-tenant isolation preserved)"
    - "Conflicts are re-checked at execution time to prevent race conditions"
    - "Audit log is updated with execution result (executed/failed + timestamp)"
    - "Unapproved actions are rejected with 403 status"
  artifacts:
    - path: "eventflow-app/supabase/functions/execute-ai-action/index.ts"
      provides: "Authenticated action executor for approved AI suggestions"
      contains: "schedule_create, schedule_update, schedule_delete, ai_insights_log, Bearer"
  key_links:
    - from: "execute-ai-action"
      to: "ai_insights_log"
      via: "SELECT approved action + UPDATE execution result"
      pattern: "ai_insights_log.*approved.*executed"
    - from: "execute-ai-action"
      to: "schedules table"
      via: "INSERT/UPDATE/DELETE with user JWT (RLS enforced)"
      pattern: "schedules.*(insert|update|delete)"
    - from: "execute-ai-action Authorization"
      to: "Supabase client"
      via: "Bearer token from Authorization header creates authenticated client"
      pattern: "Authorization.*Bearer.*createClient"
---

<objective>
Create a new Edge Function that executes approved AI actions with full RLS enforcement. This is the "execute" phase of the suggest -> confirm -> execute pattern.

Purpose: Separating execution from suggestion ensures that (1) writes use the authenticated user's JWT (enforcing RLS/multi-tenant isolation), (2) conflicts are re-checked at execution time (preventing race conditions), and (3) the audit trail records the full lifecycle.

Output: New execute-ai-action Edge Function deployable to Supabase.
</objective>

<execution_context>
@/Users/eliyawolfman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eliyawolfman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ai-write-foundation/06-RESEARCH.md
@.planning/phases/06-ai-write-foundation/06-01-SUMMARY.md
@eventflow-scaffold/supabase/functions/ai-chat/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create execute-ai-action Edge Function</name>
  <files>eventflow-app/supabase/functions/execute-ai-action/index.ts</files>
  <action>
Create a new Edge Function at `eventflow-app/supabase/functions/execute-ai-action/index.ts`.

**Structure:**

1. **CORS configuration** - Reuse the same isAllowedOrigin / getCorsHeaders pattern from ai-chat/index.ts (copy the CORS block).

2. **Authentication** - Extract user JWT from Authorization header:
   - Check for `Authorization: Bearer <token>` header
   - If missing or invalid, return 401
   - Create Supabase client with ANON KEY (NOT service_role_key) passing user JWT in headers
   - This ensures all database operations go through RLS

3. **Request validation** - Parse JSON body expecting `{ action_id: string }`:
   - Validate action_id is a non-empty string
   - Return 400 if missing

4. **Fetch and validate audit entry**:
   - Query ai_insights_log for the action_id
   - Verify execution_status = 'approved' (reject if not)
   - If not found or not approved, return 403 with error message

5. **Re-check conflicts at execution time** (for schedule_create and schedule_update):
   - Copy the detectScheduleConflicts logic from research (or call the check_speaker_conflicts DB function)
   - If error-severity conflicts found, update ai_insights_log to 'failed' with conflict details and return error
   - This prevents race conditions between approval and execution

6. **Execute action based on action_type**:

   ```typescript
   switch (auditEntry.action_type) {
     case 'schedule_create': {
       // Extract insert data from action_data
       // Ensure event_id is present
       // INSERT into schedules table (RLS will verify user belongs to event's org)
       // Return created schedule item
       break
     }
     case 'schedule_update': {
       // Extract schedule_id and changes from action_data
       // UPDATE schedules SET changes WHERE id = schedule_id
       // Return updated schedule item
       break
     }
     case 'schedule_delete': {
       // Extract schedule_id from action_data
       // DELETE from schedules WHERE id = schedule_id
       // Return success
       break
     }
     default:
       throw new Error(`Unknown action type: ${auditEntry.action_type}`)
   }
   ```

7. **Update audit log with execution result**:
   - On success: SET executed_at = NOW(), execution_status = 'executed'
   - On failure: SET executed_at = NOW(), execution_status = 'failed', execution_error = error message
   - NOTE: For the audit log UPDATE, we need a service_role client (the user's JWT may not have UPDATE permission on ai_insights_log for execution_status changes). Create a second Supabase client with service_role_key ONLY for audit log updates. Document this clearly.

8. **Response format**:
   - Success: `{ success: true, data: <created/updated schedule item> }`
   - Failure: `{ success: false, error: <error message> }`

**CRITICAL SECURITY:**
- The main Supabase client (for schedules table operations) MUST use user JWT via anon key
- Only the audit log update uses service_role_key (because RLS may restrict status updates)
- NEVER use service_role_key for schedules/events/participants operations
- Comment this security boundary clearly in the code

**Conflict re-check implementation:**
For schedule_create and schedule_update, before executing the write:
- Query schedules table for room conflicts (same event_id, same room, overlapping time range)
- If room is specified and conflicts found, fail with Hebrew error message
- The PostgreSQL exclusion constraint is the final safety net, but we check in code first for better error messages

**Error handling:**
- Wrap all operations in try/catch
- On any error, update ai_insights_log with 'failed' status
- Return appropriate HTTP status codes (401, 403, 400, 500)
- All error messages in Hebrew for user-facing errors
  </action>
  <verify>
1. Edge Function file exists with correct Deno imports
2. Authentication extracts Bearer token and creates authenticated Supabase client
3. Audit entry lookup requires execution_status = 'approved'
4. Conflict re-check runs before schedule writes
5. Schedule operations use user JWT client (RLS enforced)
6. Audit log updates use service_role client
7. All error paths update ai_insights_log with 'failed' status
8. CORS headers present on all responses
  </verify>
  <done>
execute-ai-action Edge Function exists and handles schedule_create, schedule_update, and schedule_delete actions. Writes use authenticated user JWT (RLS enforced). Conflicts are re-checked at execution time. Audit log is updated with execution results.
  </done>
</task>

</tasks>

<verification>
1. Edge Function file is valid TypeScript for Deno runtime
2. User JWT is extracted from Authorization header (not hardcoded)
3. Supabase client uses anon key + user JWT (NOT service_role_key) for schedule writes
4. Only approved actions can be executed (status check)
5. Conflict re-check prevents race conditions
6. Audit log records full lifecycle (suggested -> approved -> executed/failed)
7. All error paths are handled and logged
</verification>

<success_criteria>
The Edge Function can be deployed to Supabase. When called with a valid action_id for an approved AI suggestion, it executes the schedule change using the authenticated user's permissions, re-checks for conflicts, updates the audit trail, and returns the result. Unapproved or non-existent actions are rejected. Multi-tenant isolation is preserved via RLS.
</success_criteria>

<output>
After completion, create `.planning/phases/06-ai-write-foundation/06-03-SUMMARY.md`
</output>
