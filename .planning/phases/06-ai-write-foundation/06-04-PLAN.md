---
phase: 06-ai-write-foundation
plan: 04
type: execute
wave: 3
depends_on: ["06-02", "06-03"]
files_modified:
  - eventflow-app/src/types/chat.ts
  - eventflow-app/src/hooks/useAIConfirmation.ts
  - eventflow-app/src/components/chat/AIConfirmationDialog.tsx
  - eventflow-app/src/services/chatService.ts
  - eventflow-app/src/contexts/ChatContext.tsx
  - eventflow-app/src/components/chat/ChatWindow.tsx
autonomous: true

must_haves:
  truths:
    - "AI suggestions with pending_approval status trigger a confirmation dialog in the chat UI"
    - "Confirmation dialog shows action description, conflict warnings, and VIP impact in Hebrew"
    - "Manager can approve or reject AI suggestions from the dialog"
    - "Approved actions are executed via execute-ai-action Edge Function"
    - "Rejected actions are logged and dialog closes without execution"
    - "Existing chat functionality (messages, slash commands, settings) works unchanged"
  artifacts:
    - path: "eventflow-app/src/hooks/useAIConfirmation.ts"
      provides: "Hook managing AI confirmation workflow state"
      contains: "pendingAction, approve, reject, requestConfirmation"
    - path: "eventflow-app/src/components/chat/AIConfirmationDialog.tsx"
      provides: "Confirmation modal for AI write operations"
      contains: "AIConfirmationDialog, conflicts, vip_warning, approve, reject"
    - path: "eventflow-app/src/types/chat.ts"
      provides: "Extended types for pending_approval actions"
      contains: "AIAction, ScheduleConflict, ActionRisk, pending_approval"
  key_links:
    - from: "ChatContext.tsx"
      to: "useAIConfirmation hook"
      via: "Integration of confirmation state into chat context"
      pattern: "useAIConfirmation|pendingAction"
    - from: "AIConfirmationDialog"
      to: "execute-ai-action Edge Function"
      via: "supabase.functions.invoke on approval"
      pattern: "execute-ai-action|functions.invoke"
    - from: "chatService.ts"
      to: "AIConfirmationDialog"
      via: "Detect pending_approval actions in response and trigger dialog"
      pattern: "pending_approval|requestConfirmation"
---

<objective>
Build the frontend confirmation workflow that bridges AI suggestions and action execution. When the AI chat returns a pending_approval action, display a confirmation dialog showing the proposed change, conflicts, and VIP impact. On approval, execute via the execute-ai-action Edge Function. On rejection, log and close.

Purpose: This is the "confirm" phase of the suggest -> confirm -> execute pattern. It implements the core UX principle: "The system recommends - the user decides." The manager sees exactly what will change, any conflicts, and which VIPs are affected before approving.

Output: New types, hook, and component wired into the existing chat system.
</objective>

<execution_context>
@/Users/eliyawolfman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eliyawolfman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ai-write-foundation/06-RESEARCH.md
@.planning/phases/06-ai-write-foundation/06-02-SUMMARY.md
@.planning/phases/06-ai-write-foundation/06-03-SUMMARY.md
@eventflow-app/src/types/chat.ts
@eventflow-app/src/services/chatService.ts
@eventflow-app/src/contexts/ChatContext.tsx
@eventflow-app/src/components/chat/ChatWindow.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AI action types and confirmation hook</name>
  <files>
    eventflow-app/src/types/chat.ts
    eventflow-app/src/hooks/useAIConfirmation.ts
  </files>
  <action>
**1. Extend types/chat.ts** (APPEND, do not modify existing types):

Add these new types AFTER the existing type definitions:

```typescript
// ============================================================================
// AI Write Action Types (Phase 6)
// ============================================================================

export interface ScheduleConflict {
  type: 'room_overlap' | 'speaker_overlap' | 'capacity_overflow'
  severity: 'error' | 'warning'
  message: string
  conflicting_item?: {
    id: string
    title: string
    start_time: string
    end_time: string
  }
}

export interface AIWriteAction {
  action_id: string
  type: 'schedule_create' | 'schedule_update' | 'schedule_delete'
  status: 'pending_approval'
  data: Record<string, unknown>
  conflicts: ScheduleConflict[]
  impact: {
    affected_participants: number
    vip_count: number
    requires_notifications: boolean
  }
  label: string
  vip_warning?: string
}

export type ActionRisk = 'low' | 'medium' | 'high' | 'critical'
```

Also add to the ActionType union:
```typescript
  | 'ai_write_pending'
  | 'ai_write_approved'
  | 'ai_write_rejected'
  | 'ai_write_executed'
  | 'ai_write_failed'
```

**2. Create hooks/useAIConfirmation.ts:**

```typescript
import { useState, useCallback } from 'react'
import type { AIWriteAction } from '../types/chat'
import { supabase } from '../lib/supabase'

export function useAIConfirmation() {
  const [pendingAction, setPendingAction] = useState<AIWriteAction | null>(null)
  const [isDialogOpen, setIsDialogOpen] = useState(false)
  const [isExecuting, setIsExecuting] = useState(false)

  const requestConfirmation = useCallback((action: AIWriteAction) => {
    setPendingAction(action)
    setIsDialogOpen(true)
  }, [])

  const approve = useCallback(async (): Promise<{ success: boolean; data?: unknown; error?: string }> => {
    if (!pendingAction) return { success: false, error: 'No pending action' }
    setIsExecuting(true)

    try {
      // Step 1: Update audit log status to 'approved'
      const { error: approveError } = await supabase
        .from('ai_insights_log')
        .update({
          approved_at: new Date().toISOString(),
          execution_status: 'approved'
        })
        .eq('id', pendingAction.action_id)

      if (approveError) {
        console.error('[AI Confirm] Failed to update approval status:', approveError)
        // Continue anyway - execute-ai-action will also check
      }

      // Step 2: Execute via Edge Function (uses user JWT for RLS)
      const { data, error } = await supabase.functions.invoke('execute-ai-action', {
        body: { action_id: pendingAction.action_id }
      })

      if (error) {
        console.error('[AI Confirm] Execution error:', error)
        return { success: false, error: String(error) }
      }

      if (data?.error) {
        return { success: false, error: data.error }
      }

      return { success: true, data: data?.data }
    } catch (err) {
      console.error('[AI Confirm] Unexpected error:', err)
      return { success: false, error: err instanceof Error ? err.message : 'שגיאה לא צפויה' }
    } finally {
      setIsExecuting(false)
      setIsDialogOpen(false)
      setPendingAction(null)
    }
  }, [pendingAction])

  const reject = useCallback(async () => {
    if (!pendingAction) return

    try {
      // Log rejection to audit trail
      await supabase
        .from('ai_insights_log')
        .update({ execution_status: 'rejected' })
        .eq('id', pendingAction.action_id)
    } catch (err) {
      console.error('[AI Confirm] Failed to log rejection:', err)
    }

    setIsDialogOpen(false)
    setPendingAction(null)
  }, [pendingAction])

  const dismiss = useCallback(() => {
    setIsDialogOpen(false)
    setPendingAction(null)
  }, [])

  // Risk assessment
  const getActionRisk = useCallback((action: AIWriteAction): ActionRisk => {
    if (action.type === 'schedule_delete' && action.impact.affected_participants > 0) {
      return 'critical'
    }
    if (action.conflicts.some(c => c.severity === 'error')) {
      return 'high'
    }
    if (action.impact.vip_count > 0) {
      return 'medium'
    }
    return 'low'
  }, [])

  return {
    pendingAction,
    isDialogOpen,
    isExecuting,
    requestConfirmation,
    approve,
    reject,
    dismiss,
    getActionRisk
  }
}
```

Import `supabase` from `../lib/supabase` (this import already exists in the project).
  </action>
  <verify>
1. New types added to chat.ts without modifying existing types
2. ActionType union extended with new ai_write_* variants
3. useAIConfirmation hook exports all required functions
4. approve() calls supabase.functions.invoke('execute-ai-action')
5. reject() updates ai_insights_log status to 'rejected'
6. getActionRisk() returns correct risk level based on action properties
7. No TypeScript compilation errors
  </verify>
  <done>
Types extended with AIWriteAction, ScheduleConflict, ActionRisk. useAIConfirmation hook manages full confirmation lifecycle (request -> approve/reject -> execute). Risk assessment categorizes actions by impact.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AIConfirmationDialog and wire into chat system</name>
  <files>
    eventflow-app/src/components/chat/AIConfirmationDialog.tsx
    eventflow-app/src/services/chatService.ts
    eventflow-app/src/contexts/ChatContext.tsx
    eventflow-app/src/components/chat/ChatWindow.tsx
  </files>
  <action>
**1. Create components/chat/AIConfirmationDialog.tsx:**

RTL-first Hebrew UI component. Use existing project styling patterns (Tailwind, dark theme as used in ChatWindow.tsx).

Structure:
- Import framer-motion for animations (already used in ChatWindow)
- Import lucide-react icons: AlertTriangle, XCircle, CheckCircle, Crown, X, Loader2
- Import useAIConfirmation hook and AIWriteAction type

Props: `{ action: AIWriteAction; risk: ActionRisk; onApprove: () => void; onReject: () => void; isExecuting: boolean }`

Layout:
- Overlay backdrop (semi-transparent dark)
- Modal card with:
  - **Header**: Risk icon (colored by risk level) + action.label in Hebrew
  - **VIP Warning** (if action.vip_warning): Purple banner with Crown icon
  - **Conflicts Section** (if action.conflicts.length > 0): List each conflict with severity-colored icons. Error conflicts in red, warnings in orange/yellow
  - **Impact Summary**: affected_participants count, vip_count, requires_notifications indicator
  - **Current vs Proposed** (for schedule_update): Two-column layout showing old and new values
  - **Footer**: Cancel button (right side for RTL) + Approve button (left side for RTL)
    - Approve button disabled if any error-severity conflicts exist
    - Approve button shows spinner when isExecuting
    - Button text varies by risk: 'critical' -> red button "מחק" / 'high' -> orange "המשך בכל זאת" / default -> blue "אישור"
    - Cancel text: "ביטול"

Style matching: Use the same dark theme colors from ChatWindow (gray-900 backgrounds, gray-300 text, accentColor from settings).

**2. Modify chatService.ts** (MINIMAL change):

In the GeminiService.chat() method, in the section that processes `data.actions` (around line 295-302), add detection of pending_approval actions:

After building `backendActions`, check if any action has `data.status === 'pending_approval'`:
```typescript
// Detect pending_approval actions (AI write suggestions requiring confirmation)
const pendingApprovalActions = (data.actions || []).filter(
  (a: Record<string, unknown>) => a.status === 'pending_approval' || a.data?.status === 'pending_approval'
)
```

Include these in the returned ChatResponse. Add a new optional field to ChatResponse type:
```typescript
export interface ChatResponse {
  content: string
  actions?: ChatAction[]
  metadata?: MessageMetadata
  suggestions?: string[]
  pendingApprovalActions?: AIWriteAction[]  // NEW
}
```

Map the backend pending_approval actions to AIWriteAction type and include in response.

**3. Modify ChatContext.tsx** (MINIMAL change):

In the ChatProvider:
a. Import useAIConfirmation hook
b. Call useAIConfirmation() inside the provider
c. In sendMessage(), after receiving response, check for `response.pendingApprovalActions`:
   - If present and non-empty, call requestConfirmation(response.pendingApprovalActions[0]) for the first action
   - (Future: batching multiple actions is deferred per research Open Question #1)
d. Export the confirmation state and functions through context:
   - Add to ChatContextValue interface: `aiConfirmation: ReturnType<typeof useAIConfirmation>`
   - Add to the value object: `aiConfirmation`
e. After approve/reject, add a system message to chat describing the result:
   - On approve success: "הפעולה בוצעה בהצלחה: {action.label}"
   - On approve failure: "הפעולה נכשלה: {error}"
   - On reject: "הפעולה בוטלה: {action.label}"

**4. Modify ChatWindow.tsx** (MINIMAL change):

a. Import AIConfirmationDialog component
b. Access aiConfirmation from useChatContext()
c. Render AIConfirmationDialog conditionally:
   ```tsx
   {aiConfirmation.isDialogOpen && aiConfirmation.pendingAction && (
     <AIConfirmationDialog
       action={aiConfirmation.pendingAction}
       risk={aiConfirmation.getActionRisk(aiConfirmation.pendingAction)}
       onApprove={handleApprove}
       onReject={aiConfirmation.reject}
       isExecuting={aiConfirmation.isExecuting}
     />
   )}
   ```
d. Create handleApprove function that:
   - Calls aiConfirmation.approve()
   - On success, adds system message "הפעולה בוצעה בהצלחה"
   - On failure, adds system message with error

Render the dialog as a fixed overlay ABOVE the chat window (z-index 50+), not inside the scrollable messages area.

**Critical constraints:**
- Do NOT restructure existing ChatContext reducer or action types
- Do NOT modify ChatMessage, ChatInput, FloatingChat, or ChatSettings components
- Do NOT change the message flow for non-AI-write messages
- Preserve all existing keyboard shortcuts, settings persistence, agent switching
- The confirmation dialog must work in RTL layout
  </action>
  <verify>
1. AIConfirmationDialog renders with correct RTL layout
2. Dialog shows conflicts with severity-colored indicators
3. VIP warning banner appears when action.vip_warning is present
4. Approve button disabled when error-severity conflicts exist
5. chatService.ts correctly detects pending_approval actions
6. ChatContext.tsx triggers confirmation dialog on pending_approval
7. Approve calls execute-ai-action, reject updates audit log
8. System messages added to chat after approve/reject
9. Existing chat functionality unchanged (send message, slash commands, settings)
  </verify>
  <done>
Confirmation dialog renders for AI write suggestions. Manager sees action description, conflicts (severity-colored), VIP impact, and current-vs-proposed comparison. Approve executes via Edge Function with user JWT. Reject logs to audit trail. System messages confirm result. All existing chat features work unchanged.
  </done>
</task>

</tasks>

<verification>
1. Send "Add workshop at 2pm in Room A" in chat -> AI suggests schedule creation -> confirmation dialog appears
2. Dialog shows action details in Hebrew with RTL layout
3. If room conflict exists, dialog shows red conflict warning and blocks approval
4. If VIP participants affected, purple VIP banner appears
5. Click "אישור" -> executes via execute-ai-action -> success message in chat
6. Click "ביטול" -> rejection logged -> dialog closes -> rejection message in chat
7. Regular chat messages (non-write) work exactly as before (no confirmation dialog)
8. Settings, slash commands, agent switching all unchanged
</verification>

<success_criteria>
The complete suggest -> confirm -> execute flow works end-to-end in the UI. Manager asks AI to modify a schedule, sees a preview with conflicts and impact, approves or rejects, and gets feedback. The audit trail records the full lifecycle. Existing v1.0 chat functionality is completely preserved.
</success_criteria>

<output>
After completion, create `.planning/phases/06-ai-write-foundation/06-04-SUMMARY.md`
</output>
