---
phase: 08-offline-vendor-intelligence
plan: 02
type: feature
wave: 1
depends_on: []
files_modified:
  - package.json (dexie dependency)
  - src/modules/checkin/db/schema.ts
  - src/modules/checkin/db/db.ts
  - src/modules/checkin/db/operations.ts
  - src/modules/checkin/types.ts
autonomous: true
must_haves:
  - Dexie.js 4.x installed and configured
  - IndexedDB schema defined for check-ins and participants
  - CheckIn and CachedParticipant types defined
  - Database instance exports work (can be imported)
  - TTL field (expiresAt) present on cached participants for 24h cleanup
---

# Plan 08-02: Dexie.js IndexedDB Setup

## Objective

Install Dexie.js and create IndexedDB schema for offline check-in storage. This establishes the foundation for offline-first check-in capability.

## Context

**From RESEARCH.md:**
- Dexie.js 4.x is ecosystem standard for React/TypeScript IndexedDB
- Store participants individually (not as array) to avoid UI blocking
- Include `synced: boolean` and `syncRetries: number` on check-ins
- 24-hour TTL for cached data (Safari ITP workaround)

**From CONTEXT.md:**
- Local check-in data kept for 24 hours before requiring sync/cleanup
- Last-wins rule for duplicate check-ins

**Existing check-in:**
- CheckinPage.tsx loads participants via Supabase query
- No offline support currently

## Tasks

<task id="1" title="Install Dexie.js">
Install Dexie.js and react hooks:

```bash
cd eventflow-app
npm install dexie@^4.0.0 dexie-react-hooks
```

Verify installation in package.json.

</task>

<task id="2" title="Create IndexedDB Schema">
Create `src/modules/checkin/db/schema.ts`:

```typescript
// IndexedDB schema for offline check-in support
// Uses Dexie.js for browser storage with 24h TTL

export interface OfflineCheckIn {
  id?: number                    // Auto-increment local ID
  participantId: string          // Supabase participant UUID
  eventId: string                // Event UUID
  checkedInAt: Date              // Timestamp of check-in
  synced: boolean                // Has been synced to Supabase
  syncRetries: number            // Number of sync attempts
  lastSyncAttempt?: Date         // Last sync attempt timestamp
}

export interface CachedParticipant {
  id: string                     // Supabase participant UUID (primary key)
  eventId: string                // Event UUID
  firstName: string
  lastName: string
  phone: string
  status: string                 // 'confirmed' | 'checked_in' etc
  isVip: boolean
  hasCompanion: boolean
  qrCode: string                 // Generated QR code (EF-XXXXXXXX)
  cachedAt: Date                 // When this record was cached
  expiresAt: Date                // 24h TTL for Safari ITP compliance
}

// Database version history for migrations
export const DB_VERSION = 1
export const DB_NAME = 'EventFlowCheckIn'

// TTL constants
export const PARTICIPANT_TTL_MS = 24 * 60 * 60 * 1000  // 24 hours
```

</task>

<task id="3" title="Create Dexie Database Instance">
Create `src/modules/checkin/db/db.ts`:

```typescript
import Dexie, { Table } from 'dexie'
import { OfflineCheckIn, CachedParticipant, DB_NAME, DB_VERSION } from './schema'

export class CheckInDatabase extends Dexie {
  checkIns!: Table<OfflineCheckIn>
  participants!: Table<CachedParticipant>

  constructor() {
    super(DB_NAME)

    this.version(DB_VERSION).stores({
      // Indexes: ++id = auto-increment, & = unique
      checkIns: '++id, participantId, eventId, synced, checkedInAt',
      participants: 'id, eventId, status, expiresAt'
    })
  }
}

// Singleton instance
export const db = new CheckInDatabase()
```

</task>

<task id="4" title="Create Database Operations">
Create `src/modules/checkin/db/operations.ts`:

```typescript
import { db } from './db'
import { OfflineCheckIn, CachedParticipant, PARTICIPANT_TTL_MS } from './schema'

// ============== Check-In Operations ==============

export async function addOfflineCheckIn(
  participantId: string,
  eventId: string
): Promise<number> {
  const checkIn: OfflineCheckIn = {
    participantId,
    eventId,
    checkedInAt: new Date(),
    synced: false,
    syncRetries: 0
  }

  // Check for existing unsynced check-in (dedup)
  const existing = await db.checkIns
    .where({ participantId, eventId, synced: false })
    .first()

  if (existing) {
    // Last-wins: update timestamp
    await db.checkIns.update(existing.id!, { checkedInAt: new Date() })
    return existing.id!
  }

  return db.checkIns.add(checkIn)
}

export async function getPendingCheckIns(eventId?: string): Promise<OfflineCheckIn[]> {
  let query = db.checkIns.where('synced').equals(false)

  if (eventId) {
    const results = await query.toArray()
    return results.filter(c => c.eventId === eventId)
  }

  return query.toArray()
}

export async function markCheckInSynced(localId: number): Promise<void> {
  await db.checkIns.update(localId, { synced: true })
}

export async function incrementSyncRetry(localId: number): Promise<void> {
  const checkIn = await db.checkIns.get(localId)
  if (checkIn) {
    await db.checkIns.update(localId, {
      syncRetries: checkIn.syncRetries + 1,
      lastSyncAttempt: new Date()
    })
  }
}

// ============== Participant Cache Operations ==============

export async function cacheParticipants(
  participants: CachedParticipant[],
  eventId: string
): Promise<void> {
  const now = new Date()
  const expiresAt = new Date(now.getTime() + PARTICIPANT_TTL_MS)

  const withTTL = participants.map(p => ({
    ...p,
    eventId,
    cachedAt: now,
    expiresAt
  }))

  // Bulk upsert - Dexie handles conflicts
  await db.participants.bulkPut(withTTL)
}

export async function getCachedParticipants(
  eventId: string
): Promise<CachedParticipant[]> {
  const now = new Date()

  return db.participants
    .where('eventId')
    .equals(eventId)
    .filter(p => p.expiresAt > now)  // Filter expired
    .toArray()
}

export async function updateCachedParticipantStatus(
  participantId: string,
  status: string
): Promise<void> {
  await db.participants.update(participantId, { status })
}

export async function clearExpiredCache(): Promise<number> {
  const now = new Date()
  return db.participants
    .where('expiresAt')
    .below(now)
    .delete()
}

export async function clearEventCache(eventId: string): Promise<void> {
  await db.participants.where('eventId').equals(eventId).delete()
  await db.checkIns.where('eventId').equals(eventId).delete()
}
```

</task>

<task id="5" title="Create Index Export">
Create `src/modules/checkin/db/index.ts`:

```typescript
export { db, CheckInDatabase } from './db'
export * from './schema'
export * from './operations'
```

</task>

## Verification

```typescript
// Test in browser console or unit test
import { db, addOfflineCheckIn, getPendingCheckIns, cacheParticipants } from './db'

// Test 1: Database opens
console.assert(db.isOpen() || await db.open())

// Test 2: Add check-in
const id = await addOfflineCheckIn('test-participant', 'test-event')
console.assert(typeof id === 'number')

// Test 3: Get pending
const pending = await getPendingCheckIns()
console.assert(pending.length > 0)

// Test 4: Cache participants
await cacheParticipants([
  { id: 'p1', firstName: 'Test', lastName: 'User', ... }
], 'test-event')
const cached = await getCachedParticipants('test-event')
console.assert(cached.length === 1)
```

## Notes

- This plan creates the data layer only (no UI changes)
- Plan 08-03 will add sync service and hooks
- Plan 08-06 will integrate with CheckinPage.tsx
- Safari ITP: 24h TTL ensures data isn't lost to 7-day deletion
