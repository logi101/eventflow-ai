---
phase: 08-offline-vendor-intelligence
plan: 03
type: feature
wave: 2
depends_on:
  - 08-02
files_modified:
  - src/modules/checkin/hooks/useOnlineStatus.ts
  - src/modules/checkin/hooks/useSyncQueue.ts
  - src/modules/checkin/hooks/useOfflineCheckIn.ts
  - src/modules/checkin/services/syncService.ts
  - src/modules/checkin/components/ConnectionStatus.tsx
autonomous: true
must_haves:
  - useOnlineStatus hook returns boolean isOnline state
  - useSyncQueue hook returns pending count with live updates
  - syncService syncs pending check-ins to Supabase with exponential backoff
  - Sync respects rate limits (max 10 requests per minute, shared with reminder system)
  - ConnectionStatus shows toast on connection change (not persistent banner)
  - Pending count only visible when offline (per CONTEXT.md)
---

# Plan 08-03: Offline Sync Service and Online Status

## Objective

Create the sync infrastructure that bridges IndexedDB and Supabase, with online/offline detection and rate-limited background sync.

## Context

**From CONTEXT.md:**
- Automatic background sync when connection returns (no manual trigger)
- Sync respects existing reminder system rate limits (shared quota)
- Connection status shown as toast on change (not persistent)
- Pending count visible only when offline

**From RESEARCH.md:**
- navigator.onLine + online/offline events for detection
- Background Sync API for reliability (fallback for Safari)
- Exponential backoff with jitter
- Rate limit: share quota with reminder system

**Rate Limiting Strategy:**
- Global rate limit: 10 requests/minute for sync operations
- Track via localStorage counter with minute-based expiry
- This prevents overwhelming Supabase when many offline check-ins sync

## Tasks

<task id="1" title="Create Online Status Hook">
Create `src/modules/checkin/hooks/useOnlineStatus.ts`:

```typescript
import { useState, useEffect, useCallback } from 'react'

export function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine)
  const [lastChange, setLastChange] = useState<Date | null>(null)

  useEffect(() => {
    function handleOnline() {
      setIsOnline(true)
      setLastChange(new Date())
    }

    function handleOffline() {
      setIsOnline(false)
      setLastChange(new Date())
    }

    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)

    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [])

  return { isOnline, lastChange }
}
```

</task>

<task id="2" title="Create Sync Queue Hook">
Create `src/modules/checkin/hooks/useSyncQueue.ts`:

```typescript
import { useLiveQuery } from 'dexie-react-hooks'
import { db } from '../db'

export function useSyncQueue(eventId?: string) {
  // Live query - updates automatically when IndexedDB changes
  const pendingCount = useLiveQuery(
    async () => {
      if (eventId) {
        return db.checkIns
          .where({ synced: false, eventId })
          .count()
      }
      return db.checkIns.where('synced').equals(false).count()
    },
    [eventId],
    0  // Default value while loading
  )

  const pendingCheckIns = useLiveQuery(
    async () => {
      const query = db.checkIns.where('synced').equals(false)
      if (eventId) {
        const all = await query.toArray()
        return all.filter(c => c.eventId === eventId)
      }
      return query.toArray()
    },
    [eventId],
    []
  )

  return {
    pendingCount: pendingCount ?? 0,
    pendingCheckIns: pendingCheckIns ?? [],
    hasPending: (pendingCount ?? 0) > 0
  }
}
```

</task>

<task id="3" title="Create Sync Service">
Create `src/modules/checkin/services/syncService.ts`:

```typescript
import { supabase } from '../../../lib/supabase'
import { db, getPendingCheckIns, markCheckInSynced, incrementSyncRetry } from '../db'
import type { OfflineCheckIn } from '../db/schema'

// Rate limiting configuration
const RATE_LIMIT_KEY = 'eventflow_sync_rate_limit'
const MAX_REQUESTS_PER_MINUTE = 10
const RATE_WINDOW_MS = 60 * 1000
const MAX_RETRY_COUNT = 5

interface RateLimitState {
  count: number
  windowStart: number
}

// ============== Rate Limiting ==============

function getRateLimitState(): RateLimitState {
  const stored = localStorage.getItem(RATE_LIMIT_KEY)
  if (!stored) {
    return { count: 0, windowStart: Date.now() }
  }

  const state = JSON.parse(stored) as RateLimitState
  const now = Date.now()

  // Reset if window expired
  if (now - state.windowStart > RATE_WINDOW_MS) {
    return { count: 0, windowStart: now }
  }

  return state
}

function incrementRateLimit(): boolean {
  const state = getRateLimitState()

  if (state.count >= MAX_REQUESTS_PER_MINUTE) {
    return false  // Rate limited
  }

  const newState = {
    count: state.count + 1,
    windowStart: state.windowStart
  }
  localStorage.setItem(RATE_LIMIT_KEY, JSON.stringify(newState))
  return true
}

function canMakeRequest(): boolean {
  const state = getRateLimitState()
  return state.count < MAX_REQUESTS_PER_MINUTE
}

// ============== Exponential Backoff ==============

function getBackoffDelay(retryCount: number): number {
  // 200ms, 400ms, 800ms, 1600ms, 3200ms + jitter
  const baseDelay = 200 * Math.pow(2, retryCount)
  const jitter = Math.random() * baseDelay * 0.3  // 30% jitter
  return Math.min(baseDelay + jitter, 5000)  // Cap at 5 seconds
}

async function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms))
}

// ============== Sync Operations ==============

async function syncSingleCheckIn(checkIn: OfflineCheckIn): Promise<boolean> {
  if (!canMakeRequest()) {
    console.log('[Sync] Rate limited, will retry later')
    return false
  }

  if (checkIn.syncRetries >= MAX_RETRY_COUNT) {
    console.warn(`[Sync] Max retries exceeded for check-in ${checkIn.id}`)
    return false
  }

  try {
    incrementRateLimit()

    const { error } = await supabase
      .from('participants')
      .update({
        status: 'checked_in',
        checked_in_at: checkIn.checkedInAt.toISOString()
      })
      .eq('id', checkIn.participantId)

    if (error) {
      if (error.code === '429') {
        // Server rate limited - back off more
        await delay(getBackoffDelay(checkIn.syncRetries + 2))
      }
      throw error
    }

    await markCheckInSynced(checkIn.id!)
    console.log(`[Sync] Check-in ${checkIn.id} synced successfully`)
    return true

  } catch (error) {
    console.error(`[Sync] Failed to sync check-in ${checkIn.id}:`, error)
    await incrementSyncRetry(checkIn.id!)
    return false
  }
}

export async function syncPendingCheckIns(eventId?: string): Promise<{
  synced: number
  failed: number
  rateLimited: boolean
}> {
  const pending = await getPendingCheckIns(eventId)

  if (pending.length === 0) {
    return { synced: 0, failed: 0, rateLimited: false }
  }

  console.log(`[Sync] Starting sync of ${pending.length} pending check-ins`)

  let synced = 0
  let failed = 0
  let rateLimited = false

  for (const checkIn of pending) {
    if (!canMakeRequest()) {
      rateLimited = true
      console.log('[Sync] Rate limited, stopping batch')
      break
    }

    const success = await syncSingleCheckIn(checkIn)
    if (success) {
      synced++
    } else {
      failed++
    }

    // Small delay between requests to be nice to the server
    await delay(100)
  }

  console.log(`[Sync] Complete: ${synced} synced, ${failed} failed, rateLimited: ${rateLimited}`)
  return { synced, failed, rateLimited }
}

// Auto-sync when coming online
export function setupAutoSync() {
  window.addEventListener('online', async () => {
    console.log('[Sync] Connection restored, starting auto-sync')
    // Small delay to ensure stable connection
    await delay(1000)
    await syncPendingCheckIns()
  })
}

// Export for manual trigger if needed
export { canMakeRequest, MAX_REQUESTS_PER_MINUTE }
```

</task>

<task id="4" title="Create Offline Check-In Hook">
Create `src/modules/checkin/hooks/useOfflineCheckIn.ts`:

```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '../../../lib/supabase'
import { addOfflineCheckIn, updateCachedParticipantStatus } from '../db'
import { syncPendingCheckIns } from '../services/syncService'
import { useOnlineStatus } from './useOnlineStatus'

interface CheckInResult {
  participantId: string
  localId: number
  synced: boolean
}

export function useOfflineCheckIn(eventId: string) {
  const queryClient = useQueryClient()
  const { isOnline } = useOnlineStatus()

  return useMutation({
    mutationFn: async (participantId: string): Promise<CheckInResult> => {
      // Always write to IndexedDB first (offline-safe)
      const localId = await addOfflineCheckIn(participantId, eventId)

      // Update local cache immediately
      await updateCachedParticipantStatus(participantId, 'checked_in')

      // If online, try to sync immediately
      if (isOnline) {
        try {
          const { error } = await supabase
            .from('participants')
            .update({
              status: 'checked_in',
              checked_in_at: new Date().toISOString()
            })
            .eq('id', participantId)

          if (!error) {
            // Mark as synced in IndexedDB
            const { db } = await import('../db')
            await db.checkIns.update(localId, { synced: true })
            return { participantId, localId, synced: true }
          }
        } catch (e) {
          console.warn('[CheckIn] Online sync failed, stored locally:', e)
        }
      }

      return { participantId, localId, synced: false }
    },

    // Optimistic update for instant UI feedback
    onMutate: async (participantId) => {
      await queryClient.cancelQueries({ queryKey: ['participants', eventId] })

      const previous = queryClient.getQueryData(['participants', eventId])

      // Optimistically update TanStack Query cache
      queryClient.setQueryData(['participants', eventId], (old: any) => {
        if (!old) return old
        return old.map((p: any) =>
          p.id === participantId
            ? { ...p, status: 'checked_in', checked_in_at: new Date().toISOString() }
            : p
        )
      })

      return { previous }
    },

    onError: (err, participantId, context) => {
      // Rollback on error
      if (context?.previous) {
        queryClient.setQueryData(['participants', eventId], context.previous)
      }
    },

    onSettled: () => {
      // Always invalidate to ensure fresh data
      queryClient.invalidateQueries({ queryKey: ['participants', eventId] })
    }
  })
}

// Hook for manual sync trigger (if needed)
export function useManualSync(eventId?: string) {
  const { isOnline } = useOnlineStatus()

  return useMutation({
    mutationFn: async () => {
      if (!isOnline) {
        throw new Error('Cannot sync while offline')
      }
      return syncPendingCheckIns(eventId)
    }
  })
}
```

</task>

<task id="5" title="Create Connection Status Component">
Create `src/modules/checkin/components/ConnectionStatus.tsx`:

```typescript
import { useEffect, useRef } from 'react'
import { Wifi, WifiOff, RefreshCw } from 'lucide-react'
import { useOnlineStatus } from '../hooks/useOnlineStatus'
import { useSyncQueue } from '../hooks/useSyncQueue'

interface ConnectionStatusProps {
  eventId?: string
  showPendingWhenOnline?: boolean  // Default false per CONTEXT.md
}

export function ConnectionStatus({
  eventId,
  showPendingWhenOnline = false
}: ConnectionStatusProps) {
  const { isOnline, lastChange } = useOnlineStatus()
  const { pendingCount } = useSyncQueue(eventId)
  const toastRef = useRef<HTMLDivElement>(null)
  const prevOnlineRef = useRef(isOnline)

  // Show toast on connection change
  useEffect(() => {
    if (prevOnlineRef.current !== isOnline && lastChange) {
      // Show toast
      const toast = toastRef.current
      if (toast) {
        toast.classList.remove('opacity-0', 'translate-y-2')
        toast.classList.add('opacity-100', 'translate-y-0')

        // Auto-hide after 3 seconds
        setTimeout(() => {
          toast.classList.add('opacity-0', 'translate-y-2')
          toast.classList.remove('opacity-100', 'translate-y-0')
        }, 3000)
      }
    }
    prevOnlineRef.current = isOnline
  }, [isOnline, lastChange])

  // Pending count badge - only show when offline (per CONTEXT.md)
  const showPending = pendingCount > 0 && (!isOnline || showPendingWhenOnline)

  return (
    <>
      {/* Status Badge (always visible) */}
      <div className="flex items-center gap-2">
        {isOnline ? (
          <span className="flex items-center gap-1.5 text-xs text-emerald-400">
            <Wifi className="w-3.5 h-3.5" />
            <span>מחובר</span>
          </span>
        ) : (
          <span className="flex items-center gap-1.5 text-xs text-amber-400">
            <WifiOff className="w-3.5 h-3.5" />
            <span>לא מחובר</span>
          </span>
        )}

        {showPending && (
          <span className="flex items-center gap-1 px-2 py-0.5 bg-amber-500/20 text-amber-400 text-xs rounded-full">
            <RefreshCw className="w-3 h-3" />
            <span>{pendingCount} ממתינים</span>
          </span>
        )}
      </div>

      {/* Toast for connection changes */}
      <div
        ref={toastRef}
        className={`fixed bottom-4 left-1/2 transform -translate-x-1/2 z-50 px-4 py-2 rounded-xl shadow-lg transition-all duration-300 opacity-0 translate-y-2 ${
          isOnline
            ? 'bg-gradient-to-r from-green-500 to-emerald-500 text-white'
            : 'bg-gradient-to-r from-amber-500 to-orange-500 text-white'
        }`}
      >
        <div className="flex items-center gap-2">
          {isOnline ? (
            <>
              <Wifi className="w-4 h-4" />
              <span>חיבור שוחזר - מסנכרן...</span>
            </>
          ) : (
            <>
              <WifiOff className="w-4 h-4" />
              <span>אין חיבור - מצב לא מקוון</span>
            </>
          )}
        </div>
      </div>
    </>
  )
}
```

</task>

<task id="6" title="Create Index Export">
Create `src/modules/checkin/hooks/index.ts`:

```typescript
export { useOnlineStatus } from './useOnlineStatus'
export { useSyncQueue } from './useSyncQueue'
export { useOfflineCheckIn, useManualSync } from './useOfflineCheckIn'
```

Update or create `src/modules/checkin/components/index.ts`:

```typescript
export { ConnectionStatus } from './ConnectionStatus'
```

</task>

## Verification

```typescript
// Test 1: Online status hook
const { isOnline } = useOnlineStatus()
console.assert(typeof isOnline === 'boolean')

// Test 2: Sync queue hook
const { pendingCount, hasPending } = useSyncQueue('event-123')
console.assert(typeof pendingCount === 'number')

// Test 3: Rate limiting
import { canMakeRequest } from '../services/syncService'
for (let i = 0; i < 12; i++) {
  const allowed = canMakeRequest()
  if (i >= 10) console.assert(!allowed, 'Should be rate limited')
}

// Test 4: ConnectionStatus renders
// Visual test in browser - check toast appears on network toggle
```

## Notes

- Auto-sync triggers on 'online' event via setupAutoSync()
- Rate limit shared across all sync operations (10/min)
- Pending count only visible offline to avoid clutter
- Toast appears for 3 seconds on connection change
