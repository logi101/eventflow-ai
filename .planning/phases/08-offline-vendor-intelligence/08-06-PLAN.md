---
phase: 08-offline-vendor-intelligence
plan: 06
type: integration
wave: 3
depends_on:
  - 08-03
files_modified:
  - eventflow-app/src/pages/checkin/CheckinPage.tsx
  - eventflow-app/src/main.tsx (or App.tsx)
autonomous: true
must_haves:
  - CheckinPage uses IndexedDB for participant list when offline
  - QR check-in works without internet (writes to IndexedDB first)
  - ConnectionStatus component visible in CheckinPage header
  - Participant list preloads into IndexedDB when page loads online
  - Check-in button shows immediate feedback (optimistic update)
  - Auto-sync setup runs on app initialization
---

# Plan 08-06: Offline Check-In UI Integration

## Objective

Integrate offline check-in capabilities into the existing CheckinPage, making QR check-in work reliably without internet connection.

## Context

**From CONTEXT.md:**
- Check-in must work reliably in venue basements/parking lots with poor signal
- Offline mode only for check-in (not full app)
- Local check-in data kept for 24 hours

**Existing CheckinPage.tsx:**
- Loads participants via `supabase.from('participants').select()`
- Check-in via `supabase.from('participants').update()`
- Has scan mode and manual code entry
- Shows stats (total, checked_in, pending, VIP)

**From Plans 08-02 and 08-03:**
- Dexie.js database for IndexedDB storage
- useOfflineCheckIn hook for offline-safe mutations
- useOnlineStatus and useSyncQueue hooks
- ConnectionStatus component for status display
- syncService for background sync

## Tasks

<task id="1" title="Update CheckinPage Data Loading">
Modify `eventflow-app/src/pages/checkin/CheckinPage.tsx` to use offline-first data loading:

**Add imports:**
```typescript
import { useOnlineStatus } from '../../modules/checkin/hooks/useOnlineStatus'
import { useSyncQueue } from '../../modules/checkin/hooks/useSyncQueue'
import { useOfflineCheckIn } from '../../modules/checkin/hooks/useOfflineCheckIn'
import { ConnectionStatus } from '../../modules/checkin/components/ConnectionStatus'
import {
  cacheParticipants,
  getCachedParticipants,
  clearExpiredCache
} from '../../modules/checkin/db'
```

**Replace fetchParticipants function:**
```typescript
async function fetchParticipants() {
  setLoading(true)

  // Clear expired cache on each load
  await clearExpiredCache()

  // Try online first
  if (navigator.onLine) {
    try {
      const { data } = await supabase
        .from('participants')
        .select('*')
        .eq('event_id', selectedEventId)
        .order('last_name', { ascending: true })

      if (data) {
        // Generate QR codes and cache
        const participantsWithQR = data.map(p => ({
          ...p,
          qr_code: `EF-${p.id.substring(0, 8).toUpperCase()}`
        }))

        // Cache for offline use
        await cacheParticipants(
          participantsWithQR.map(p => ({
            id: p.id,
            eventId: p.event_id,
            firstName: p.first_name,
            lastName: p.last_name,
            phone: p.phone,
            status: p.status,
            isVip: p.is_vip || false,
            hasCompanion: p.has_companion || false,
            qrCode: p.qr_code
          })),
          selectedEventId
        )

        setParticipants(participantsWithQR)
        setLoading(false)
        return
      }
    } catch (e) {
      console.warn('[CheckIn] Online fetch failed, trying cache:', e)
    }
  }

  // Fallback to cached data
  const cached = await getCachedParticipants(selectedEventId)
  if (cached.length > 0) {
    // Convert cached format back to component format
    const participantsFromCache = cached.map(p => ({
      id: p.id,
      event_id: p.eventId,
      first_name: p.firstName,
      last_name: p.lastName,
      phone: p.phone,
      status: p.status,
      is_vip: p.isVip,
      has_companion: p.hasCompanion,
      qr_code: p.qrCode
    }))
    setParticipants(participantsFromCache as CheckinParticipant[])
  } else {
    setParticipants([])
  }

  setLoading(false)
}
```

</task>

<task id="2" title="Replace Check-In Function with Offline Hook">
Replace the `checkInParticipant` function to use offline-safe mutation:

**In component body:**
```typescript
const { isOnline } = useOnlineStatus()
const { pendingCount } = useSyncQueue(selectedEventId)
const offlineCheckIn = useOfflineCheckIn(selectedEventId)

// Replace existing checkInParticipant
async function checkInParticipant(participantId: string) {
  try {
    const result = await offlineCheckIn.mutateAsync(participantId)

    const participant = participants.find(p => p.id === participantId)

    setCheckInResult({
      success: true,
      message: `${participant?.first_name} ${participant?.last_name} נרשם/ה בהצלחה!${
        !result.synced ? ' (ממתין לסנכרון)' : ''
      }`,
      participant
    })

    // Update local state immediately for UI
    setParticipants(prev =>
      prev.map(p =>
        p.id === participantId
          ? { ...p, status: 'checked_in', checked_in_at: new Date().toISOString() }
          : p
      )
    )

  } catch (error) {
    setCheckInResult({
      success: false,
      message: 'שגיאה בצ\'ק-אין'
    })
  }

  setTimeout(() => setCheckInResult(null), 3000)
}
```

</task>

<task id="3" title="Add ConnectionStatus to Header">
Add ConnectionStatus component to the page header:

```tsx
{/* Header */}
<div className="flex items-center justify-between mb-8">
  <div>
    <p className="text-cyan-400/80 text-sm font-medium mb-1">כניסת משתתפים</p>
    <h1 className="text-3xl font-bold text-white" data-testid="checkin-title">צ'ק-אין</h1>
    <p className="text-zinc-400 mt-1">ניהול הגעה וסריקת QR</p>
  </div>
  <div className="flex items-center gap-4">
    {/* Connection Status */}
    <ConnectionStatus eventId={selectedEventId} />

    <button
      className={`flex items-center gap-2 px-5 py-2.5 rounded-xl font-medium transition-all duration-300 ${
        scanMode
          ? 'bg-[#1a1d27] border border-white/5 text-zinc-300 hover:bg-white/5'
          : 'bg-gradient-to-r from-cyan-500 to-blue-500 text-white shadow-lg shadow-cyan-500/30 hover:shadow-xl hover:-translate-y-0.5'
      }`}
      onClick={() => setScanMode(!scanMode)}
      data-testid="toggle-scan-mode"
    >
      <ScanLine className="w-4 h-4" />
      {scanMode ? 'חזרה לרשימה' : 'מצב סריקה'}
    </button>
  </div>
</div>
```

</task>

<task id="4" title="Update Undo Check-In for Online-Only">
Per CONTEXT.md, check-in reversal (undo) behavior is Claude's discretion. The safest approach is online-only to avoid sync conflicts:

```typescript
async function undoCheckIn(participantId: string) {
  // Undo only works when online (prevents sync conflicts)
  if (!navigator.onLine) {
    setCheckInResult({
      success: false,
      message: 'ביטול צ\'ק-אין זמין רק במצב מקוון'
    })
    setTimeout(() => setCheckInResult(null), 3000)
    return
  }

  const { error } = await supabase
    .from('participants')
    .update({
      status: 'confirmed',
      checked_in_at: null
    })
    .eq('id', participantId)

  if (error) {
    setCheckInResult({
      success: false,
      message: 'שגיאה בביטול צ\'ק-אין'
    })
  } else {
    // Update local state
    setParticipants(prev =>
      prev.map(p =>
        p.id === participantId
          ? { ...p, status: 'confirmed', checked_in_at: null }
          : p
      )
    )

    // Also update cache
    await updateCachedParticipantStatus(participantId, 'confirmed')
  }

  setTimeout(() => setCheckInResult(null), 3000)
}
```

Update the undo button to show disabled state when offline:

```tsx
<button
  className={`px-4 py-2 rounded-xl border transition-all duration-300 ${
    !isOnline
      ? 'bg-zinc-800/50 text-zinc-500 border-zinc-700 cursor-not-allowed'
      : 'bg-[#1a1d27]/80 text-zinc-400 border-white/10 hover:bg-white/5 hover:border-white/20'
  }`}
  onClick={() => undoCheckIn(participant.id)}
  disabled={!isOnline}
  title={!isOnline ? 'ביטול זמין רק במצב מקוון' : 'בטל צ\'ק-אין'}
>
  ביטול
</button>
```

</task>

<task id="5" title="Setup Auto-Sync on App Init">
Update `eventflow-app/src/main.tsx` (or App.tsx) to initialize auto-sync:

```typescript
// At the top level, after imports
import { setupAutoSync } from './modules/checkin/services/syncService'

// Initialize auto-sync (runs once on app load)
setupAutoSync()
```

This ensures that when the app regains connectivity, any pending check-ins are automatically synced.

</task>

<task id="6" title="Add Visual Indicator for Pending Sync">
Update the participant card to show a subtle indicator when a check-in is pending sync:

```tsx
// In the participant card, after the check-in timestamp:
{participant.status === 'checked_in' && (
  <div className="flex items-center gap-2">
    {participant.checked_in_at && (
      <p className="text-xs text-emerald-400 mt-1">
        נרשם ב-{new Date(participant.checked_in_at).toLocaleTimeString('he-IL')}
      </p>
    )}
    {/* Show if this check-in is in the pending queue */}
    {/* This would require checking IndexedDB - optional enhancement */}
  </div>
)}
```

Note: Full pending indicator per-participant would require checking IndexedDB for each participant, which may be expensive. The global pending count in ConnectionStatus is usually sufficient.

</task>

## Verification

**Offline Flow Test:**
1. Load CheckinPage with internet on - participants should load and cache
2. Disconnect internet (airplane mode or dev tools)
3. Refresh page - participants should load from IndexedDB
4. Check in a participant - should succeed with "(ממתין לסנכרון)" message
5. Reconnect internet - auto-sync should trigger, pending count should drop
6. Verify check-in appears in Supabase

**Manual Test Cases:**
- [ ] Online load: participants fetched from Supabase and cached
- [ ] Offline load: participants loaded from IndexedDB
- [ ] Offline check-in: immediate success, stored locally
- [ ] Online check-in: syncs immediately to Supabase
- [ ] Connection change: toast appears, auto-sync triggers
- [ ] Undo offline: blocked with message
- [ ] Undo online: works normally

## Notes

- Undo check-in is online-only to prevent sync conflicts (simplest safe approach)
- Auto-sync runs on connection restore (via online event listener)
- 24-hour TTL on cached participants prevents stale data
- Stats (total, checked_in, etc) update optimistically for immediate feedback
