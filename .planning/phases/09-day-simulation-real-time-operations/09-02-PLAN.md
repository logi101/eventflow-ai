---
phase: 09-day-simulation-real-time-operations
plan: 02
title: Simulation Validators & Engine
type: feature
wave: 2
depends_on: [09-01]
files_modified:
  - eventflow-app/src/modules/simulation/services/validators/roomConflicts.ts
  - eventflow-app/src/modules/simulation/services/validators/speakerOverlaps.ts
  - eventflow-app/src/modules/simulation/services/validators/capacityValidation.ts
  - eventflow-app/src/modules/simulation/services/validators/transitionTimes.ts
  - eventflow-app/src/modules/simulation/services/validators/equipmentChecks.ts
  - eventflow-app/src/modules/simulation/services/validators/vipSchedule.ts
  - eventflow-app/src/modules/simulation/services/validators/cateringGaps.ts
  - eventflow-app/src/modules/simulation/services/validators/backToBack.ts
  - eventflow-app/src/modules/simulation/services/validators/index.ts
  - eventflow-app/src/modules/simulation/services/simulationEngine.ts
  - eventflow-app/src/modules/simulation/services/dataFetcher.ts
  - eventflow-app/src/modules/simulation/services/index.ts
autonomous: true
must_haves:
  - 8 validators implemented (room, speaker, capacity, transitions, equipment, VIP, catering, back-to-back)
  - Each validator returns SimulationIssue[] with deterministic IDs
  - Simulation engine runs all validators in parallel
  - Results sorted deterministically (severity > category > id)
  - No database writes during simulation (pure validation)
  - date-fns areIntervalsOverlapping used for time overlap detection
---

# Phase 9 Plan 2: Simulation Validators & Engine

## Objective

Implement 8 validators that detect specific event day issues and an orchestrator engine that runs them all, aggregates results, and ensures deterministic output ordering.

## Context

**From CONTEXT.md:**
- Comprehensive detection: room conflicts, speaker overlaps, capacity exceeded, short transitions, back-to-back sessions for same speaker, missing equipment assignments, VIP schedule conflicts, catering gaps
- Three severity levels: Critical / Warning / Info
- Full context per issue: problem description + affected entities + link to schedule item + one-click fix action

**From RESEARCH.md:**
- Simulation is pure validation (no database writes)
- Run all validators in parallel, aggregate results deterministically
- Use date-fns `areIntervalsOverlapping()` for time overlap detection
- Generate deterministic issue IDs (hash of content, not random UUID)

**From Phase 6:**
- Existing conflict detection patterns in schedules module
- Room conflicts enforced by database constraint (GIST exclusion)
- Speaker conflicts detected at application level

## Tasks

<task id="1" name="create-data-fetcher">
### Task 1: Create Data Fetcher Service

Fetches all event data needed by validators in a single parallel call.

**File:** `src/modules/simulation/services/dataFetcher.ts`

```typescript
import type { SupabaseClient } from '@supabase/supabase-js'
import type {
  SimulationInput,
  ScheduleData,
  ParticipantScheduleData,
  VendorScheduleData,
  EquipmentData,
} from '../types'

/**
 * Fetches all event data needed for simulation in parallel.
 * Orders all results consistently for deterministic simulation.
 */
export async function fetchSimulationData(
  supabase: SupabaseClient,
  eventId: string
): Promise<SimulationInput> {
  // Fetch all data in parallel
  const [
    schedulesResult,
    participantSchedulesResult,
    vendorsResult,
  ] = await Promise.all([
    // 1. Schedules with room and speaker info
    supabase
      .from('schedules')
      .select(`
        id,
        event_id,
        title,
        start_time,
        end_time,
        session_type,
        expected_attendance,
        equipment_required,
        backup_speaker_id,
        room:rooms(id, name, capacity),
        speaker:speakers(id, name)
      `)
      .eq('event_id', eventId)
      .eq('is_deleted', false)
      .order('start_time', { ascending: true })
      .order('id', { ascending: true }), // Tie-breaker for determinism

    // 2. Participant schedules for transition checking
    supabase
      .from('participant_schedules')
      .select(`
        participant_id,
        schedule_id,
        participant:participants(id, first_name, last_name, is_vip),
        schedule:schedules(id, title, start_time, end_time, room:rooms(id, name))
      `)
      .eq('schedules.event_id', eventId)
      .order('participant_id', { ascending: true })
      .order('schedules.start_time', { ascending: true }),

    // 3. Vendors for catering gap checking
    supabase
      .from('event_vendors')
      .select(`
        vendor_id,
        service_start,
        service_end,
        vendor:vendors(id, name, category)
      `)
      .eq('event_id', eventId)
      .order('vendor_id', { ascending: true }),
  ])

  // Transform schedules data
  const schedules: ScheduleData[] = (schedulesResult.data || []).map(s => ({
    id: s.id,
    event_id: s.event_id,
    title: s.title,
    start_time: s.start_time,
    end_time: s.end_time,
    room_id: s.room?.id || null,
    room_name: s.room?.name || null,
    room_capacity: s.room?.capacity || null,
    speaker_id: s.speaker?.id || null,
    speaker_name: s.speaker?.name || null,
    backup_speaker_id: s.backup_speaker_id,
    session_type: s.session_type,
    expected_attendance: s.expected_attendance,
    equipment_required: s.equipment_required || [],
  }))

  // Transform participant schedules
  const participantSchedules: ParticipantScheduleData[] = (participantSchedulesResult.data || [])
    .filter(ps => ps.participant && ps.schedule)
    .map(ps => ({
      participant_id: ps.participant_id,
      participant_name: `${ps.participant.first_name} ${ps.participant.last_name}`,
      is_vip: ps.participant.is_vip || false,
      schedule_id: ps.schedule_id,
      schedule_title: ps.schedule.title,
      start_time: ps.schedule.start_time,
      end_time: ps.schedule.end_time,
      room_id: ps.schedule.room?.id || null,
      room_name: ps.schedule.room?.name || null,
    }))

  // Transform vendors
  const vendors: VendorScheduleData[] = (vendorsResult.data || [])
    .filter(v => v.vendor)
    .map(v => ({
      vendor_id: v.vendor_id,
      vendor_name: v.vendor.name,
      category: v.vendor.category,
      schedule_id: null, // Vendors aren't tied to specific schedules
      service_start: v.service_start,
      service_end: v.service_end,
    }))

  // Equipment data derived from schedules
  const equipment: EquipmentData[] = schedules
    .filter(s => s.equipment_required && s.equipment_required.length > 0)
    .map(s => ({
      schedule_id: s.id,
      required: s.equipment_required || [],
      assigned: [], // TODO: Load from equipment_assignments table if exists
    }))

  return {
    event_id: eventId,
    schedules,
    participantSchedules,
    vendors,
    equipment,
  }
}
```
</task>

<task id="2" name="create-validators">
### Task 2: Create 8 Validators

Implement each validator as a pure function that returns SimulationIssue[].

**File:** `src/modules/simulation/services/validators/roomConflicts.ts`

```typescript
import { areIntervalsOverlapping, parseISO } from 'date-fns'
import type { ScheduleData } from '../../types'
import type { SimulationIssue } from '../../types'

/**
 * Detects room double-booking conflicts.
 * Severity: CRITICAL (rooms cannot be in two places at once)
 */
export function validateRoomConflicts(schedules: ScheduleData[]): SimulationIssue[] {
  const issues: SimulationIssue[] = []

  // Group schedules by room
  const byRoom = new Map<string, ScheduleData[]>()
  for (const schedule of schedules) {
    if (!schedule.room_id) continue
    const existing = byRoom.get(schedule.room_id) || []
    existing.push(schedule)
    byRoom.set(schedule.room_id, existing)
  }

  // Check each room for overlaps
  for (const [roomId, roomSchedules] of byRoom) {
    // Sort by start time for determinism
    const sorted = [...roomSchedules].sort((a, b) =>
      a.start_time.localeCompare(b.start_time) || a.id.localeCompare(b.id)
    )

    for (let i = 0; i < sorted.length; i++) {
      for (let j = i + 1; j < sorted.length; j++) {
        const a = sorted[i]
        const b = sorted[j]

        const overlaps = areIntervalsOverlapping(
          { start: parseISO(a.start_time), end: parseISO(a.end_time) },
          { start: parseISO(b.start_time), end: parseISO(b.end_time) },
          { inclusive: false } // Exact end/start is OK (back-to-back)
        )

        if (overlaps) {
          // Deterministic ID: sorted IDs concatenated
          const ids = [a.id, b.id].sort()
          issues.push({
            id: `room-conflict-${ids[0]}-${ids[1]}`,
            severity: 'critical',
            category: 'room',
            title: `התנגשות באולם ${a.room_name || roomId}`,
            description: `"${a.title}" ו-"${b.title}" מתוכננים באותו אולם בזמנים חופפים`,
            affectedEntities: {
              schedule_ids: [a.id, b.id],
              room_ids: [roomId],
            },
            suggestedFix: {
              type: 'reassign_room',
              action_data: { schedule_id: b.id, current_room: roomId },
              label: `שנה אולם ל-"${b.title}"`,
            },
          })
        }
      }
    }
  }

  return issues
}
```

**File:** `src/modules/simulation/services/validators/speakerOverlaps.ts`

```typescript
import { areIntervalsOverlapping, parseISO } from 'date-fns'
import type { ScheduleData, SimulationIssue } from '../../types'

/**
 * Detects speaker double-booking (same speaker at two sessions).
 * Severity: CRITICAL (speaker cannot be in two places)
 */
export function validateSpeakerOverlaps(schedules: ScheduleData[]): SimulationIssue[] {
  const issues: SimulationIssue[] = []

  // Group schedules by speaker
  const bySpeaker = new Map<string, ScheduleData[]>()
  for (const schedule of schedules) {
    if (!schedule.speaker_id) continue
    const existing = bySpeaker.get(schedule.speaker_id) || []
    existing.push(schedule)
    bySpeaker.set(schedule.speaker_id, existing)
  }

  // Check each speaker for overlaps
  for (const [speakerId, speakerSchedules] of bySpeaker) {
    const sorted = [...speakerSchedules].sort((a, b) =>
      a.start_time.localeCompare(b.start_time) || a.id.localeCompare(b.id)
    )

    for (let i = 0; i < sorted.length; i++) {
      for (let j = i + 1; j < sorted.length; j++) {
        const a = sorted[i]
        const b = sorted[j]

        const overlaps = areIntervalsOverlapping(
          { start: parseISO(a.start_time), end: parseISO(a.end_time) },
          { start: parseISO(b.start_time), end: parseISO(b.end_time) },
          { inclusive: false }
        )

        if (overlaps) {
          const ids = [a.id, b.id].sort()
          issues.push({
            id: `speaker-overlap-${ids[0]}-${ids[1]}`,
            severity: 'critical',
            category: 'speaker',
            title: `דובר כפול: ${a.speaker_name || speakerId}`,
            description: `${a.speaker_name} מופיע ב-"${a.title}" וב-"${b.title}" בזמנים חופפים`,
            affectedEntities: {
              schedule_ids: [a.id, b.id],
              speaker_ids: [speakerId],
            },
            suggestedFix: a.backup_speaker_id ? {
              type: 'activate_backup',
              action_data: { schedule_id: b.id, backup_speaker_id: a.backup_speaker_id },
              label: `הפעל דובר חלופי ל-"${b.title}"`,
            } : undefined,
          })
        }
      }
    }
  }

  return issues
}
```

**File:** `src/modules/simulation/services/validators/capacityValidation.ts`

```typescript
import type { ScheduleData, SimulationIssue } from '../../types'

/**
 * Detects capacity issues (expected attendance vs room capacity).
 * Severity: CRITICAL if exceeded, WARNING if > 90%
 */
export function validateCapacity(schedules: ScheduleData[]): SimulationIssue[] {
  const issues: SimulationIssue[] = []

  for (const schedule of schedules) {
    if (!schedule.room_capacity || !schedule.expected_attendance) continue

    const utilization = (schedule.expected_attendance / schedule.room_capacity) * 100

    if (schedule.expected_attendance > schedule.room_capacity) {
      issues.push({
        id: `capacity-exceeded-${schedule.id}`,
        severity: 'critical',
        category: 'capacity',
        title: `חריגה מקיבולת: ${schedule.room_name}`,
        description: `${schedule.expected_attendance} משתתפים צפויים, אבל הקיבולת היא ${schedule.room_capacity} בלבד`,
        affectedEntities: {
          schedule_ids: [schedule.id],
          room_ids: schedule.room_id ? [schedule.room_id] : undefined,
        },
        suggestedFix: {
          type: 'reassign_room',
          action_data: {
            schedule_id: schedule.id,
            reason: 'capacity_exceeded',
            min_capacity_needed: schedule.expected_attendance,
          },
          label: 'העבר לאולם גדול יותר',
        },
      })
    } else if (utilization > 90) {
      issues.push({
        id: `capacity-warning-${schedule.id}`,
        severity: 'warning',
        category: 'capacity',
        title: `אולם כמעט מלא: ${schedule.room_name}`,
        description: `${schedule.expected_attendance}/${schedule.room_capacity} משתתפים (${Math.round(utilization)}%)`,
        affectedEntities: {
          schedule_ids: [schedule.id],
          room_ids: schedule.room_id ? [schedule.room_id] : undefined,
        },
      })
    }
  }

  return issues
}
```

**File:** `src/modules/simulation/services/validators/transitionTimes.ts`

```typescript
import { differenceInMinutes, parseISO } from 'date-fns'
import type { ParticipantScheduleData, SimulationIssue } from '../../types'

const MIN_TRANSITION_MINUTES = 15

/**
 * Detects short transition times between rooms for participants.
 * Severity: WARNING (participants may be late)
 */
export function validateTransitionTimes(
  participantSchedules: ParticipantScheduleData[]
): SimulationIssue[] {
  const issues: SimulationIssue[] = []
  const seenIssues = new Set<string>() // Dedupe same room transitions

  // Group by participant
  const byParticipant = new Map<string, ParticipantScheduleData[]>()
  for (const ps of participantSchedules) {
    const existing = byParticipant.get(ps.participant_id) || []
    existing.push(ps)
    byParticipant.set(ps.participant_id, existing)
  }

  for (const [participantId, schedules] of byParticipant) {
    const sorted = [...schedules].sort((a, b) =>
      a.start_time.localeCompare(b.start_time) || a.schedule_id.localeCompare(b.schedule_id)
    )

    for (let i = 0; i < sorted.length - 1; i++) {
      const current = sorted[i]
      const next = sorted[i + 1]

      // Skip if same room or no room assigned
      if (!current.room_id || !next.room_id || current.room_id === next.room_id) continue

      const gapMinutes = differenceInMinutes(
        parseISO(next.start_time),
        parseISO(current.end_time)
      )

      if (gapMinutes < MIN_TRANSITION_MINUTES) {
        // Dedupe key: room transition (not per-participant)
        const transitionKey = [current.room_id, next.room_id, current.schedule_id, next.schedule_id]
          .sort()
          .join('-')

        if (seenIssues.has(transitionKey)) continue
        seenIssues.add(transitionKey)

        issues.push({
          id: `transition-${current.schedule_id}-${next.schedule_id}`,
          severity: 'warning',
          category: 'timing',
          title: 'זמן מעבר קצר בין אולמות',
          description: `מעבר מ-${current.room_name} ל-${next.room_name} תוך ${gapMinutes} דקות בלבד (מומלץ ${MIN_TRANSITION_MINUTES} דקות)`,
          affectedEntities: {
            schedule_ids: [current.schedule_id, next.schedule_id],
            room_ids: [current.room_id, next.room_id],
          },
          suggestedFix: {
            type: 'adjust_time',
            action_data: {
              schedule_id: next.schedule_id,
              delay_minutes: MIN_TRANSITION_MINUTES - gapMinutes,
            },
            label: `הוסף ${MIN_TRANSITION_MINUTES - gapMinutes} דקות הפסקה`,
          },
        })
      }
    }
  }

  return issues
}
```

**File:** `src/modules/simulation/services/validators/equipmentChecks.ts`

```typescript
import type { EquipmentData, SimulationIssue, ScheduleData } from '../../types'

/**
 * Detects missing equipment assignments.
 * Severity: WARNING (can be solved on event day, but risky)
 */
export function validateEquipment(
  schedules: ScheduleData[],
  equipment: EquipmentData[]
): SimulationIssue[] {
  const issues: SimulationIssue[] = []

  const equipmentBySchedule = new Map(equipment.map(e => [e.schedule_id, e]))

  for (const schedule of schedules) {
    if (!schedule.equipment_required || schedule.equipment_required.length === 0) continue

    const assigned = equipmentBySchedule.get(schedule.id)
    const missingEquipment = schedule.equipment_required.filter(
      req => !assigned?.assigned.includes(req)
    )

    if (missingEquipment.length > 0) {
      issues.push({
        id: `equipment-missing-${schedule.id}`,
        severity: 'warning',
        category: 'equipment',
        title: `ציוד חסר: ${schedule.title}`,
        description: `הציוד הבא לא הוקצה: ${missingEquipment.join(', ')}`,
        affectedEntities: {
          schedule_ids: [schedule.id],
        },
        suggestedFix: {
          type: 'add_equipment',
          action_data: {
            schedule_id: schedule.id,
            missing_equipment: missingEquipment,
          },
          label: 'הקצה ציוד חסר',
        },
      })
    }
  }

  return issues
}
```

**File:** `src/modules/simulation/services/validators/vipSchedule.ts`

```typescript
import { areIntervalsOverlapping, parseISO } from 'date-fns'
import type { ParticipantScheduleData, SimulationIssue } from '../../types'

/**
 * Detects VIP schedule conflicts (VIP double-booked).
 * Severity: WARNING (VIPs are important, but this may be intentional)
 */
export function validateVIPSchedule(
  participantSchedules: ParticipantScheduleData[]
): SimulationIssue[] {
  const issues: SimulationIssue[] = []

  // Filter to VIPs only
  const vipSchedules = participantSchedules.filter(ps => ps.is_vip)

  // Group by VIP
  const byVIP = new Map<string, ParticipantScheduleData[]>()
  for (const ps of vipSchedules) {
    const existing = byVIP.get(ps.participant_id) || []
    existing.push(ps)
    byVIP.set(ps.participant_id, existing)
  }

  for (const [vipId, schedules] of byVIP) {
    const sorted = [...schedules].sort((a, b) =>
      a.start_time.localeCompare(b.start_time) || a.schedule_id.localeCompare(b.schedule_id)
    )

    for (let i = 0; i < sorted.length; i++) {
      for (let j = i + 1; j < sorted.length; j++) {
        const a = sorted[i]
        const b = sorted[j]

        const overlaps = areIntervalsOverlapping(
          { start: parseISO(a.start_time), end: parseISO(a.end_time) },
          { start: parseISO(b.start_time), end: parseISO(b.end_time) },
          { inclusive: false }
        )

        if (overlaps) {
          const ids = [a.schedule_id, b.schedule_id].sort()
          issues.push({
            id: `vip-conflict-${vipId}-${ids[0]}-${ids[1]}`,
            severity: 'warning',
            category: 'vip',
            title: `התנגשות ללקוח VIP: ${a.participant_name}`,
            description: `${a.participant_name} (VIP) רשום ל-"${a.schedule_title}" וגם ל-"${b.schedule_title}" בזמנים חופפים`,
            affectedEntities: {
              schedule_ids: [a.schedule_id, b.schedule_id],
              participant_ids: [vipId],
            },
          })
        }
      }
    }
  }

  return issues
}
```

**File:** `src/modules/simulation/services/validators/cateringGaps.ts`

```typescript
import { differenceInHours, parseISO, isWithinInterval } from 'date-fns'
import type { ScheduleData, VendorScheduleData, SimulationIssue } from '../../types'

const MAX_HOURS_WITHOUT_CATERING = 4

/**
 * Detects long gaps without catering/meals.
 * Severity: INFO (comfort issue, not critical)
 */
export function validateCateringGaps(
  schedules: ScheduleData[],
  vendors: VendorScheduleData[]
): SimulationIssue[] {
  const issues: SimulationIssue[] = []

  // Find catering vendors
  const cateringVendors = vendors.filter(v =>
    v.category.toLowerCase().includes('קייטרינג') ||
    v.category.toLowerCase().includes('catering') ||
    v.category.toLowerCase().includes('אוכל') ||
    v.category.toLowerCase().includes('food')
  )

  // Find meal/break sessions
  const mealSessions = schedules.filter(s =>
    s.session_type === 'meal' ||
    s.session_type === 'break' ||
    s.title.toLowerCase().includes('ארוחה') ||
    s.title.toLowerCase().includes('הפסקה') ||
    s.title.toLowerCase().includes('קפה')
  )

  if (schedules.length === 0) return issues

  // Sort schedules by time
  const sorted = [...schedules].sort((a, b) => a.start_time.localeCompare(b.start_time))
  const eventStart = parseISO(sorted[0].start_time)
  const eventEnd = parseISO(sorted[sorted.length - 1].end_time)
  const totalHours = differenceInHours(eventEnd, eventStart)

  // Check for gaps
  if (totalHours > MAX_HOURS_WITHOUT_CATERING && mealSessions.length === 0) {
    issues.push({
      id: `catering-gap-no-meals`,
      severity: 'info',
      category: 'catering',
      title: 'לא נקבעו הפסקות אוכל',
      description: `האירוע נמשך ${totalHours} שעות ללא הפסקות אוכל מתוכננות`,
      affectedEntities: {},
      suggestedFix: {
        type: 'add_catering',
        action_data: { recommended_breaks: Math.floor(totalHours / 3) },
        label: 'הוסף הפסקות אוכל',
      },
    })
  }

  // Check for long gaps between meals
  if (mealSessions.length > 0) {
    const mealTimes = mealSessions
      .map(m => ({ start: parseISO(m.start_time), end: parseISO(m.end_time), id: m.id }))
      .sort((a, b) => a.start.getTime() - b.start.getTime())

    // Check gap from event start to first meal
    const hoursToFirstMeal = differenceInHours(mealTimes[0].start, eventStart)
    if (hoursToFirstMeal > MAX_HOURS_WITHOUT_CATERING) {
      issues.push({
        id: `catering-gap-start`,
        severity: 'info',
        category: 'catering',
        title: 'פער ארוך לפני ארוחה ראשונה',
        description: `${hoursToFirstMeal} שעות מתחילת האירוע ועד הארוחה הראשונה`,
        affectedEntities: {
          schedule_ids: [mealTimes[0].id],
        },
      })
    }

    // Check gaps between meals
    for (let i = 0; i < mealTimes.length - 1; i++) {
      const gap = differenceInHours(mealTimes[i + 1].start, mealTimes[i].end)
      if (gap > MAX_HOURS_WITHOUT_CATERING) {
        issues.push({
          id: `catering-gap-${mealTimes[i].id}-${mealTimes[i + 1].id}`,
          severity: 'info',
          category: 'catering',
          title: 'פער ארוך בין ארוחות',
          description: `${gap} שעות בין הפסקות אוכל`,
          affectedEntities: {
            schedule_ids: [mealTimes[i].id, mealTimes[i + 1].id],
          },
        })
      }
    }
  }

  return issues
}
```

**File:** `src/modules/simulation/services/validators/backToBack.ts`

```typescript
import { differenceInMinutes, parseISO } from 'date-fns'
import type { ScheduleData, SimulationIssue } from '../../types'

const MIN_SPEAKER_BREAK_MINUTES = 15

/**
 * Detects back-to-back sessions for the same speaker.
 * Severity: WARNING (speaker fatigue, no prep time)
 */
export function validateBackToBack(schedules: ScheduleData[]): SimulationIssue[] {
  const issues: SimulationIssue[] = []

  // Group by speaker
  const bySpeaker = new Map<string, ScheduleData[]>()
  for (const schedule of schedules) {
    if (!schedule.speaker_id) continue
    const existing = bySpeaker.get(schedule.speaker_id) || []
    existing.push(schedule)
    bySpeaker.set(schedule.speaker_id, existing)
  }

  for (const [speakerId, speakerSchedules] of bySpeaker) {
    if (speakerSchedules.length < 2) continue

    const sorted = [...speakerSchedules].sort((a, b) =>
      a.start_time.localeCompare(b.start_time) || a.id.localeCompare(b.id)
    )

    for (let i = 0; i < sorted.length - 1; i++) {
      const current = sorted[i]
      const next = sorted[i + 1]

      const gapMinutes = differenceInMinutes(
        parseISO(next.start_time),
        parseISO(current.end_time)
      )

      if (gapMinutes < MIN_SPEAKER_BREAK_MINUTES) {
        issues.push({
          id: `backtoback-${current.id}-${next.id}`,
          severity: 'warning',
          category: 'backtoback',
          title: `סשנים רצופים לדובר: ${current.speaker_name}`,
          description: `${current.speaker_name} מופיע ב-"${current.title}" וב-"${next.title}" עם ${gapMinutes} דקות הפסקה בלבד`,
          affectedEntities: {
            schedule_ids: [current.id, next.id],
            speaker_ids: [speakerId],
          },
          suggestedFix: {
            type: 'extend_break',
            action_data: {
              schedule_id: next.id,
              delay_minutes: MIN_SPEAKER_BREAK_MINUTES - gapMinutes,
            },
            label: `הוסף ${MIN_SPEAKER_BREAK_MINUTES - gapMinutes} דקות הפסקה`,
          },
        })
      }
    }
  }

  return issues
}
```

**File:** `src/modules/simulation/services/validators/index.ts`

```typescript
export { validateRoomConflicts } from './roomConflicts'
export { validateSpeakerOverlaps } from './speakerOverlaps'
export { validateCapacity } from './capacityValidation'
export { validateTransitionTimes } from './transitionTimes'
export { validateEquipment } from './equipmentChecks'
export { validateVIPSchedule } from './vipSchedule'
export { validateCateringGaps } from './cateringGaps'
export { validateBackToBack } from './backToBack'
```
</task>

<task id="3" name="create-simulation-engine">
### Task 3: Create Simulation Engine

Orchestrates all validators and ensures deterministic output.

**File:** `src/modules/simulation/services/simulationEngine.ts`

```typescript
import type { SupabaseClient } from '@supabase/supabase-js'
import type { SimulationResult, SimulationIssue } from '../types'
import { fetchSimulationData } from './dataFetcher'
import {
  validateRoomConflicts,
  validateSpeakerOverlaps,
  validateCapacity,
  validateTransitionTimes,
  validateEquipment,
  validateVIPSchedule,
  validateCateringGaps,
  validateBackToBack,
} from './validators'

// Severity ordering for deterministic sorting
const severityOrder: Record<SimulationIssue['severity'], number> = {
  critical: 0,
  warning: 1,
  info: 2,
}

// Category ordering for deterministic sorting
const categoryOrder: Record<SimulationIssue['category'], number> = {
  room: 0,
  speaker: 1,
  capacity: 2,
  timing: 3,
  equipment: 4,
  vip: 5,
  catering: 6,
  backtoback: 7,
}

/**
 * Runs full day simulation for an event.
 * Pure validation - no database writes.
 * Deterministic - same input produces same output.
 */
export async function runSimulation(
  supabase: SupabaseClient,
  eventId: string
): Promise<SimulationResult> {
  const startTime = performance.now()

  // 1. Fetch all data in parallel
  const data = await fetchSimulationData(supabase, eventId)

  // 2. Run all validators in parallel
  const validatorResults = await Promise.all([
    Promise.resolve(validateRoomConflicts(data.schedules)),
    Promise.resolve(validateSpeakerOverlaps(data.schedules)),
    Promise.resolve(validateCapacity(data.schedules)),
    Promise.resolve(validateTransitionTimes(data.participantSchedules)),
    Promise.resolve(validateEquipment(data.schedules, data.equipment)),
    Promise.resolve(validateVIPSchedule(data.participantSchedules)),
    Promise.resolve(validateCateringGaps(data.schedules, data.vendors)),
    Promise.resolve(validateBackToBack(data.schedules)),
  ])

  // 3. Flatten all issues
  const allIssues = validatorResults.flat()

  // 4. Sort deterministically: severity > category > id
  const sortedIssues = allIssues.sort((a, b) => {
    // Primary: severity
    const severityDiff = severityOrder[a.severity] - severityOrder[b.severity]
    if (severityDiff !== 0) return severityDiff

    // Secondary: category
    const categoryDiff = categoryOrder[a.category] - categoryOrder[b.category]
    if (categoryDiff !== 0) return categoryDiff

    // Tertiary: id (string comparison for determinism)
    return a.id.localeCompare(b.id)
  })

  const endTime = performance.now()

  // 5. Return result
  return {
    event_id: eventId,
    run_at: new Date().toISOString(),
    total_issues: sortedIssues.length,
    critical: sortedIssues.filter(i => i.severity === 'critical').length,
    warnings: sortedIssues.filter(i => i.severity === 'warning').length,
    info: sortedIssues.filter(i => i.severity === 'info').length,
    issues: sortedIssues,
    duration_ms: Math.round(endTime - startTime),
  }
}

/**
 * Groups issues by severity for UI display.
 */
export function groupIssuesBySeverity(issues: SimulationIssue[]): {
  critical: SimulationIssue[]
  warning: SimulationIssue[]
  info: SimulationIssue[]
} {
  return {
    critical: issues.filter(i => i.severity === 'critical'),
    warning: issues.filter(i => i.severity === 'warning'),
    info: issues.filter(i => i.severity === 'info'),
  }
}
```

**File:** `src/modules/simulation/services/index.ts`

```typescript
export { runSimulation, groupIssuesBySeverity } from './simulationEngine'
export { fetchSimulationData } from './dataFetcher'
export * from './validators'
```
</task>

## Verification

After completing all tasks:

1. **All 8 validators exist:**
   - roomConflicts.ts
   - speakerOverlaps.ts
   - capacityValidation.ts
   - transitionTimes.ts
   - equipmentChecks.ts
   - vipSchedule.ts
   - cateringGaps.ts
   - backToBack.ts

2. **TypeScript compiles:**
   - Run `npx tsc --noEmit` from eventflow-app directory
   - All imports resolve correctly

3. **Deterministic output:**
   - Each validator generates deterministic issue IDs
   - simulationEngine sorts results consistently

4. **No database writes:**
   - simulationEngine only reads data
   - No INSERT/UPDATE/DELETE operations

## Files Created

- `eventflow-app/src/modules/simulation/services/dataFetcher.ts`
- `eventflow-app/src/modules/simulation/services/validators/roomConflicts.ts`
- `eventflow-app/src/modules/simulation/services/validators/speakerOverlaps.ts`
- `eventflow-app/src/modules/simulation/services/validators/capacityValidation.ts`
- `eventflow-app/src/modules/simulation/services/validators/transitionTimes.ts`
- `eventflow-app/src/modules/simulation/services/validators/equipmentChecks.ts`
- `eventflow-app/src/modules/simulation/services/validators/vipSchedule.ts`
- `eventflow-app/src/modules/simulation/services/validators/cateringGaps.ts`
- `eventflow-app/src/modules/simulation/services/validators/backToBack.ts`
- `eventflow-app/src/modules/simulation/services/validators/index.ts`
- `eventflow-app/src/modules/simulation/services/simulationEngine.ts`
- `eventflow-app/src/modules/simulation/services/index.ts`

## Dependencies

- **09-01**: Simulation types (SimulationIssue, SimulationResult, ScheduleData, etc.)

## Next Plans

- **09-04**: Uses simulationEngine to build UI components and hooks
