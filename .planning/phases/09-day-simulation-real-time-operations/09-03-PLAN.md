---
phase: 09-day-simulation-real-time-operations
plan: 03
title: Contingency Services
type: feature
wave: 2
depends_on: [09-01]
files_modified:
  - eventflow-app/src/modules/contingency/services/contingencyManager.ts
  - eventflow-app/src/modules/contingency/services/notificationService.ts
  - eventflow-app/src/modules/contingency/services/index.ts
autonomous: true
must_haves:
  - suggestContingencyAction returns pending_approval action with impact summary
  - executeContingencyAction updates schedule and logs to contingency_audit_log
  - rejectContingencyAction updates audit log with rejection status
  - notifyParticipants sends WhatsApp via existing send-whatsapp Edge Function
  - Notifications sent immediately (no batching)
  - Promise.allSettled used for parallel notification sending
  - All notification attempts logged to messages table
---

# Phase 9 Plan 3: Contingency Services

## Objective

Implement the contingency manager service (suggest+confirm pattern) and notification service for immediate WhatsApp delivery when schedule changes occur.

## Context

**From Phase 6:**
- Suggest+confirm pattern: AI suggests → manager approves → system executes
- ai_insights_log tracks full lifecycle
- execute-ai-action Edge Function pattern for authenticated execution

**From CONTEXT.md:**
- Pre-assigned backup speakers per session + ability to pick anyone ad-hoc
- Full audit log: who activated, when, what changed, reason for change
- Immediately on contingency activation (no batching)
- Simple notification content: what changed (e.g., "Session X moved to Room Y")

**From RESEARCH.md:**
- Use Promise.allSettled() for parallel notifications (handle failures gracefully)
- Log ALL notification attempts to messages table (even failures)
- Return notification summary in contingency result

## Tasks

<task id="1" name="create-contingency-manager">
### Task 1: Create Contingency Manager Service

Implements suggest → approve → execute lifecycle for contingency actions.

**File:** `src/modules/contingency/services/contingencyManager.ts`

```typescript
import type { SupabaseClient } from '@supabase/supabase-js'
import type {
  ContingencyAction,
  ContingencyActionData,
  ContingencyActionType,
  ContingencySuggestion,
  ContingencyExecutionResult,
  ImpactSummary,
  AuditEntry,
} from '../types'
import { notifyParticipants, generateChangeNotification } from './notificationService'

/**
 * Suggests a contingency action without executing it.
 * Follows Phase 6 suggest+confirm pattern.
 */
export async function suggestContingencyAction(
  supabase: SupabaseClient,
  eventId: string,
  actionType: ContingencyActionType,
  actionData: ContingencyActionData,
  reason: string,
  userId: string
): Promise<ContingencySuggestion> {
  // 1. Calculate impact BEFORE suggesting
  const impact = await calculateImpact(supabase, actionData)

  // 2. Generate Hebrew label for UI
  const label = generateActionLabel(actionType, actionData)

  // 3. Log suggestion to audit table
  const { data: auditLog, error } = await supabase
    .from('contingency_audit_log')
    .insert({
      event_id: eventId,
      action_type: actionType,
      action_data: actionData,
      execution_status: 'suggested',
      suggested_by: userId,
      suggested_at: new Date().toISOString(),
      reason,
      impact_summary: impact,
    })
    .select('id')
    .single()

  if (error) {
    throw new Error(`Failed to log contingency suggestion: ${error.message}`)
  }

  // 4. Return as pending_approval action
  return {
    action_id: auditLog.id,
    type: actionType,
    status: 'pending_approval',
    data: actionData,
    impact,
    label,
    reason,
  }
}

/**
 * Executes an approved contingency action.
 * Updates schedule, logs execution, and triggers notifications.
 */
export async function executeContingencyAction(
  supabase: SupabaseClient,
  actionId: string,
  userId: string
): Promise<ContingencyExecutionResult> {
  // 1. Get action from audit log
  const { data: action, error: fetchError } = await supabase
    .from('contingency_audit_log')
    .select('*')
    .eq('id', actionId)
    .single()

  if (fetchError || !action) {
    return {
      success: false,
      action_id: actionId,
      execution_status: 'failed',
      error_message: 'Action not found',
    }
  }

  // 2. Verify action is in correct state
  if (action.execution_status !== 'suggested' && action.execution_status !== 'approved') {
    return {
      success: false,
      action_id: actionId,
      execution_status: action.execution_status,
      error_message: `Cannot execute action in status: ${action.execution_status}`,
    }
  }

  try {
    // 3. Execute database changes based on action type
    await executeActionByType(supabase, action.action_type, action.action_data)

    // 4. Get affected participants for notifications
    const participants = await getAffectedParticipants(
      supabase,
      action.action_data.schedule_id
    )

    // 5. Send notifications immediately
    const notificationResult = await notifyParticipants(
      supabase,
      action.event_id,
      participants,
      {
        type: 'schedule_change',
        message: generateChangeNotification(action.action_type, action.action_data),
      }
    )

    // 6. Update impact summary with actual notification counts
    const finalImpact: ImpactSummary = {
      affected_participants: participants.length,
      notifications_sent: notificationResult.sent,
      notifications_failed: notificationResult.failed,
      affected_sessions: [action.action_data.schedule_id],
      vip_affected: participants.filter(p => p.is_vip).length,
    }

    // 7. Update audit log to executed status
    // Note: We insert a new row since audit log is append-only
    // But for execution status, we need to use service_role to update
    const { error: updateError } = await supabase
      .from('contingency_audit_log')
      .update({
        execution_status: 'executed',
        executed_by: userId,
        executed_at: new Date().toISOString(),
        impact_summary: finalImpact,
      })
      .eq('id', actionId)

    // Note: If using strict append-only, insert a new row instead of update
    // For now, allowing status updates on same row for simplicity

    if (updateError) {
      console.error('Failed to update audit log:', updateError)
      // Continue anyway - action was executed
    }

    return {
      success: true,
      action_id: actionId,
      execution_status: 'executed',
      impact_summary: finalImpact,
    }
  } catch (error) {
    // Log failure to audit log
    await supabase
      .from('contingency_audit_log')
      .update({
        execution_status: 'failed',
        error_message: error instanceof Error ? error.message : 'Unknown error',
      })
      .eq('id', actionId)

    return {
      success: false,
      action_id: actionId,
      execution_status: 'failed',
      error_message: error instanceof Error ? error.message : 'Unknown error',
    }
  }
}

/**
 * Rejects a suggested contingency action.
 */
export async function rejectContingencyAction(
  supabase: SupabaseClient,
  actionId: string,
  userId: string,
  rejectionReason?: string
): Promise<ContingencyExecutionResult> {
  const { error } = await supabase
    .from('contingency_audit_log')
    .update({
      execution_status: 'rejected',
      rejected_by: userId,
      rejected_at: new Date().toISOString(),
      error_message: rejectionReason,
    })
    .eq('id', actionId)

  if (error) {
    return {
      success: false,
      action_id: actionId,
      execution_status: 'failed',
      error_message: `Failed to reject action: ${error.message}`,
    }
  }

  return {
    success: true,
    action_id: actionId,
    execution_status: 'rejected',
  }
}

/**
 * Gets contingency history for an event.
 */
export async function getContingencyHistory(
  supabase: SupabaseClient,
  eventId: string
): Promise<AuditEntry[]> {
  const { data, error } = await supabase
    .from('contingency_audit_log')
    .select('*')
    .eq('event_id', eventId)
    .order('suggested_at', { ascending: false })

  if (error) {
    console.error('Failed to fetch contingency history:', error)
    return []
  }

  return data as AuditEntry[]
}

// ============================================================================
// Helper Functions
// ============================================================================

async function calculateImpact(
  supabase: SupabaseClient,
  actionData: ContingencyActionData
): Promise<ImpactSummary> {
  const participants = await getAffectedParticipants(supabase, actionData.schedule_id)

  return {
    affected_participants: participants.length,
    notifications_sent: 0, // Will be updated after execution
    affected_sessions: [actionData.schedule_id],
    vip_affected: participants.filter(p => p.is_vip).length,
  }
}

interface AffectedParticipant {
  id: string
  first_name: string
  last_name: string
  phone_normalized: string | null
  is_vip: boolean
  organization_id: string
}

async function getAffectedParticipants(
  supabase: SupabaseClient,
  scheduleId: string
): Promise<AffectedParticipant[]> {
  // Get participants enrolled in this session
  const { data, error } = await supabase
    .from('participant_schedules')
    .select(`
      participant:participants(
        id,
        first_name,
        last_name,
        phone_normalized,
        is_vip,
        organization_id
      )
    `)
    .eq('schedule_id', scheduleId)

  if (error || !data) {
    console.error('Failed to get affected participants:', error)
    return []
  }

  return data
    .filter(d => d.participant)
    .map(d => d.participant as AffectedParticipant)
}

async function executeActionByType(
  supabase: SupabaseClient,
  actionType: string,
  actionData: ContingencyActionData
): Promise<void> {
  switch (actionType) {
    case 'backup_speaker_activate':
      await supabase
        .from('schedules')
        .update({
          speaker_id: actionData.backup_speaker_id,
          original_speaker_id: actionData.original_speaker_id,
          updated_at: new Date().toISOString(),
        })
        .eq('id', actionData.schedule_id)
      break

    case 'room_change':
      await supabase
        .from('schedules')
        .update({
          room_id: actionData.new_room_id,
          updated_at: new Date().toISOString(),
        })
        .eq('id', actionData.schedule_id)
      break

    case 'time_change':
      await supabase
        .from('schedules')
        .update({
          start_time: actionData.new_start_time,
          end_time: actionData.new_end_time,
          updated_at: new Date().toISOString(),
        })
        .eq('id', actionData.schedule_id)
      break

    case 'session_cancel':
      await supabase
        .from('schedules')
        .update({
          is_deleted: true,
          updated_at: new Date().toISOString(),
        })
        .eq('id', actionData.schedule_id)
      break

    default:
      throw new Error(`Unknown action type: ${actionType}`)
  }
}

function generateActionLabel(
  actionType: ContingencyActionType,
  actionData: ContingencyActionData
): string {
  switch (actionType) {
    case 'backup_speaker_activate':
      return `החלפת דובר לסשן "${actionData.schedule_title}"`
    case 'room_change':
      return `העברת "${actionData.schedule_title}" לאולם ${actionData.new_room_name}`
    case 'time_change':
      return `שינוי שעות לסשן "${actionData.schedule_title}"`
    case 'session_cancel':
      return `ביטול סשן "${actionData.schedule_title}"`
    default:
      return `פעולה על "${actionData.schedule_title}"`
  }
}
```
</task>

<task id="2" name="create-notification-service">
### Task 2: Create Notification Service

Sends immediate WhatsApp notifications via existing send-whatsapp Edge Function.

**File:** `src/modules/contingency/services/notificationService.ts`

```typescript
import type { SupabaseClient } from '@supabase/supabase-js'
import type { ContingencyActionType, ContingencyActionData } from '../types'

interface Participant {
  id: string
  first_name: string
  last_name: string
  phone_normalized: string | null
  is_vip: boolean
  organization_id: string
}

interface NotificationPayload {
  type: 'schedule_change'
  message: string
}

interface NotificationResult {
  sent: number
  failed: number
  details: Array<{
    participant_id: string
    success: boolean
    error?: string
  }>
}

/**
 * Sends WhatsApp notifications to affected participants immediately.
 * Uses Promise.allSettled for graceful failure handling.
 * Logs all attempts to messages table.
 */
export async function notifyParticipants(
  supabase: SupabaseClient,
  eventId: string,
  participants: Participant[],
  payload: NotificationPayload
): Promise<NotificationResult> {
  // Filter to participants with phone numbers
  const withPhone = participants.filter(p => p.phone_normalized)

  if (withPhone.length === 0) {
    return { sent: 0, failed: 0, details: [] }
  }

  // Sort VIPs first for priority sending
  const sorted = [...withPhone].sort((a, b) => {
    if (a.is_vip && !b.is_vip) return -1
    if (!a.is_vip && b.is_vip) return 1
    return 0
  })

  // Send notifications in parallel using Promise.allSettled
  const results = await Promise.allSettled(
    sorted.map(async (participant) => {
      try {
        // Personalize message for VIPs
        const personalizedMessage = participant.is_vip
          ? `${participant.first_name}, ${payload.message}`
          : payload.message

        // Call send-whatsapp Edge Function
        const { error } = await supabase.functions.invoke('send-whatsapp', {
          body: {
            organization_id: participant.organization_id,
            phone: participant.phone_normalized,
            message: personalizedMessage,
            participant_id: participant.id,
          },
        })

        if (error) throw error

        // Log successful send to messages table
        await logMessage(supabase, eventId, participant, personalizedMessage, 'sent')

        return { participant_id: participant.id, success: true }
      } catch (error) {
        // Log failed send to messages table
        await logMessage(
          supabase,
          eventId,
          participant,
          payload.message,
          'failed',
          error instanceof Error ? error.message : 'Unknown error'
        )

        return {
          participant_id: participant.id,
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error',
        }
      }
    })
  )

  // Aggregate results
  const details = results.map((result, index) => {
    if (result.status === 'fulfilled') {
      return result.value
    } else {
      return {
        participant_id: sorted[index].id,
        success: false,
        error: result.reason?.message || 'Promise rejected',
      }
    }
  })

  return {
    sent: details.filter(d => d.success).length,
    failed: details.filter(d => !d.success).length,
    details,
  }
}

/**
 * Generates notification message based on action type.
 */
export function generateChangeNotification(
  actionType: ContingencyActionType,
  actionData: ContingencyActionData
): string {
  switch (actionType) {
    case 'backup_speaker_activate':
      return `עדכון: הסשן "${actionData.schedule_title}" יועבר לדובר ${actionData.backup_speaker_name || 'חלופי'}. הזמן והמיקום נותרים זהים.`

    case 'room_change':
      return `עדכון: הסשן "${actionData.schedule_title}" הועבר לאולם ${actionData.new_room_name}.`

    case 'time_change': {
      // Format time for Hebrew display
      const newStart = actionData.new_start_time
        ? new Date(actionData.new_start_time).toLocaleTimeString('he-IL', {
            hour: '2-digit',
            minute: '2-digit',
          })
        : ''
      return `עדכון: הסשן "${actionData.schedule_title}" הועבר לשעה ${newStart}.`
    }

    case 'session_cancel':
      return `עדכון: הסשן "${actionData.schedule_title}" בוטל. אנו מתנצלים על אי הנוחות.`

    case 'schedule_adjust':
      return `עדכון: חל שינוי בסשן "${actionData.schedule_title}". אנא בדקו את הלו"ז המעודכן.`

    default:
      return `עדכון: חל שינוי בלו"ז האירוע. אנא בדקו את הלו"ז המעודכן.`
  }
}

/**
 * Logs notification attempt to messages table.
 */
async function logMessage(
  supabase: SupabaseClient,
  eventId: string,
  participant: Participant,
  content: string,
  status: 'sent' | 'failed',
  errorMessage?: string
): Promise<void> {
  try {
    await supabase.from('messages').insert({
      event_id: eventId,
      participant_id: participant.id,
      channel: 'whatsapp',
      to_phone: participant.phone_normalized,
      content,
      message_type: 'schedule_update',
      status,
      sent_at: status === 'sent' ? new Date().toISOString() : null,
      error_message: errorMessage,
    })
  } catch (error) {
    // Log but don't throw - message logging shouldn't fail the notification
    console.error('Failed to log message:', error)
  }
}
```
</task>

<task id="3" name="create-services-index">
### Task 3: Create Services Index

Export all services from a single entry point.

**File:** `src/modules/contingency/services/index.ts`

```typescript
export {
  suggestContingencyAction,
  executeContingencyAction,
  rejectContingencyAction,
  getContingencyHistory,
} from './contingencyManager'

export {
  notifyParticipants,
  generateChangeNotification,
} from './notificationService'
```
</task>

## Verification

After completing all tasks:

1. **Suggest+confirm lifecycle works:**
   - suggestContingencyAction creates audit log entry with status='suggested'
   - executeContingencyAction updates schedule and sets status='executed'
   - rejectContingencyAction sets status='rejected'

2. **Notifications sent immediately:**
   - No batching delay
   - VIPs processed first (sorted order)
   - Promise.allSettled handles failures gracefully

3. **All attempts logged:**
   - Successful sends logged with status='sent'
   - Failed sends logged with status='failed' and error_message

4. **TypeScript compiles:**
   - Run `npx tsc --noEmit` from eventflow-app directory
   - All imports resolve correctly

## Files Created

- `eventflow-app/src/modules/contingency/services/contingencyManager.ts`
- `eventflow-app/src/modules/contingency/services/notificationService.ts`
- `eventflow-app/src/modules/contingency/services/index.ts`

## Dependencies

- **09-01**: Contingency types (ContingencyAction, ImpactSummary, etc.)

## Next Plans

- **09-05**: Uses contingencyManager and notificationService to build UI components and hooks
