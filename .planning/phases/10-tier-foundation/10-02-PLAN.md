---
phase: 10-tier-foundation
plan: 02
type: execute
wave: 1
depends_on: [10-01]
files_modified:
  - eventflow-app/supabase/migrations/20260204000011_add_tier_usage_triggers.sql
autonomous: true

must_haves:
  truths:
    - "increment_event_usage() function exists and increments events_count"
    - "on_event_created trigger fires AFTER INSERT on events table"
    - "increment_participant_usage() function exists and increments participants_count"
    - "on_participant_created trigger fires AFTER INSERT on participants table"
    - "increment_message_usage() function exists and increments messages_sent"
    - "on_message_sent trigger fires AFTER INSERT on messages table"
    - "All increments are atomic and handle concurrent inserts"
  artifacts:
    - path: "eventflow-app/supabase/migrations/20260204000011_add_tier_usage_triggers.sql"
      provides: "Database triggers for automatic usage tracking"
      contains: "3 increment functions, 3 triggers, atomic UPDATE pattern"
  key_links:
    - from: "events INSERT"
      to: "organizations.current_usage"
      via: "on_event_created trigger"
      pattern: "AFTER INSERT ON events"
    - from: "participants INSERT"
      to: "organizations.current_usage"
      via: "on_participant_created trigger"
      pattern: "AFTER INSERT ON participants"
    - from: "messages INSERT"
      to: "organizations.current_usage"
      via: "on_message_sent trigger"
      pattern: "AFTER INSERT ON messages"
---

<objective>
Create PostgreSQL triggers to auto-increment usage counters when events, participants, or messages are created.

Purpose: Automate usage tracking at the database level to ensure consistency and prevent race conditions. Each trigger increments the appropriate counter in organizations.current_usage when a record is inserted.

Output: Single SQL migration file with increment functions and triggers.
</objective>

<execution_context>
@/Users/eliyawolfman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eliyawolfman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md (P1.2 Database Schema: Usage Counter Triggers)
@.planning/ROADMAP.md (Phase 1: Foundation, P1.2 Tasks)
@eventflow-app/supabase/migrations/20260203000010_add_tier_columns.sql
@eventflow-scaffold/schema.sql (for events, participants, messages table structure)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create increment_event_usage function</name>
  <files>eventflow-app/supabase/migrations/20260204000011_add_tier_usage_triggers.sql</files>
  <action>
  Create PL/pgSQL function:

  ```sql
  CREATE OR REPLACE FUNCTION increment_event_usage()
  RETURNS TRIGGER AS $$
  BEGIN
    UPDATE organizations
    SET
      current_usage = jsonb_set(
        current_usage,
        '{events_count}',
        COALESCE((current_usage->>'events_count')::int, 0) + 1
      )
    WHERE id = NEW.organization_id;

    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;
  ```

  Notes:
  - Use jsonb_set for atomic increment
  - COALESCE handles NULL values
  - Triggers via organization_id foreign key on events table
  </action>
  <verify>
  1. Function compiles without errors
  2. Uses jsonb_set for atomic operation
  3. Returns NEW for AFTER INSERT trigger
  </verify>
  <done>
  Function created with jsonb_set pattern for atomic increment.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create on_event_created trigger</name>
  <files>eventflow-app/supabase/migrations/20260204000011_add_tier_usage_triggers.sql</files>
  <action>
  Create trigger:

  ```sql
  DROP TRIGGER IF EXISTS on_event_created ON events;
  CREATE TRIGGER on_event_created
  AFTER INSERT ON events
  FOR EACH ROW
  EXECUTE FUNCTION increment_event_usage();
  ```

  Notes:
  - DROP IF EXISTS for idempotent migration
  - AFTER INSERT ensures data exists before increment
  - FOR EACH ROW ensures every event increments usage
  </action>
  <verify>
  1. Trigger syntax is valid
  2. Fires AFTER INSERT (not BEFORE)
  3. FOR EACH ROW behavior
  </verify>
  <done>
  Trigger created to fire after event insertion.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create increment_participant_usage function</name>
  <files>eventflow-app/supabase/migrations/20260204000011_add_tier_usage_triggers.sql</files>
  <action>
  Create PL/pgSQL function:

  ```sql
  CREATE OR REPLACE FUNCTION increment_participant_usage()
  RETURNS TRIGGER AS $$
  BEGIN
    UPDATE organizations o
    SET
      current_usage = jsonb_set(
        o.current_usage,
        '{participants_count}',
        COALESCE((o.current_usage->>'participants_count')::int, 0) + 1
      )
    FROM events e
    WHERE e.id = NEW.event_id
      AND o.id = e.organization_id;

    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;
  ```

  Notes:
  - Join to events table to get organization_id
  - Uses NEW.event_id foreign key
  - Atomic increment via jsonb_set
  </action>
  <verify>
  1. Function compiles without errors
  2. Joins events table correctly
  3. Atomic increment via jsonb_set
  </verify>
  <done>
  Function created with join to events table.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create on_participant_created trigger</name>
  <files>eventflow-app/supabase/migrations/20260204000011_add_tier_usage_triggers.sql</files>
  <action>
  Create trigger:

  ```sql
  DROP TRIGGER IF EXISTS on_participant_created ON participants;
  CREATE TRIGGER on_participant_created
  AFTER INSERT ON participants
  FOR EACH ROW
  EXECUTE FUNCTION increment_participant_usage();
  ```

  Notes:
  - Same pattern as on_event_created
  - Ensures participant creation increments counter
  </action>
  <verify>
  1. Trigger syntax is valid
  2. Fires AFTER INSERT on participants
  </verify>
  <done>
  Trigger created to fire after participant insertion.
  </done>
</task>

<task type="auto">
  <name>Task 5: Create increment_message_usage function</name>
  <files>eventflow-app/supabase/migrations/20260204000011_add_tier_usage_triggers.sql</files>
  <action>
  Create PL/pgSQL function:

  ```sql
  CREATE OR REPLACE FUNCTION increment_message_usage()
  RETURNS TRIGGER AS $$
  BEGIN
    UPDATE organizations o
    SET
      current_usage = jsonb_set(
        o.current_usage,
        '{messages_sent}',
        COALESCE((o.current_usage->>'messages_sent')::int, 0) + 1
      )
    FROM events e
    WHERE e.id = NEW.event_id
      AND o.id = e.organization_id;

    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;
  ```

  Notes:
  - Same pattern as increment_participant_usage
  - Join to events table via NEW.event_id
  </action>
  <verify>
  1. Function compiles without errors
  2. Joins events table correctly
  3. Atomic increment via jsonb_set
  </verify>
  <done>
  Function created for message usage tracking.
  </done>
</task>

<task type="auto">
  <name>Task 6: Create on_message_sent trigger</name>
  <files>eventflow-app/supabase/migrations/20260204000011_add_tier_usage_triggers.sql</files>
  <action>
  Create trigger:

  ```sql
  DROP TRIGGER IF EXISTS on_message_sent ON messages;
  CREATE TRIGGER on_message_sent
  AFTER INSERT ON messages
  FOR EACH ROW
  EXECUTE FUNCTION increment_message_usage();
  ```

  Notes:
  - Fires after message insertion
  - Includes all message types (WhatsApp, email, SMS)
  </action>
  <verify>
  1. Trigger syntax is valid
  2. Fires AFTER INSERT on messages
  </verify>
  <done>
  Trigger created to fire after message insertion.
  </done>
</task>

<task type="auto">
  <name>Task 7: Add migration comments and tests</name>
  <files>eventflow-app/supabase/migrations/20260204000011_add_tier_usage_triggers.sql</files>
  <action>
  Add to migration file:

  1. **Migration header**:
     ```sql
     -- Migration 011: Add Tier Usage Counter Triggers
     -- EventFlow AI v2.1 - SaaS Tier Structure
     -- Date: 2026-02-04
     ```

  2. **Section comments** (Hebrew and English):
     ```sql
     -- פונקציות לעדכון מוני שימוש (Usage Counter Functions)
     -- Increment functions update organizations.current_usage JSONB atomically
     ```

  3. **Test queries** (for manual verification):
     ```sql
     -- Test: Create event and verify counter increment
     INSERT INTO events (organization_id, title, ...) VALUES (test_org_id, 'Test Event', ...);
     SELECT current_usage->>'events_count' FROM organizations WHERE id = test_org_id;
     ```
  </action>
  <verify>
  1. All sections have clear comments
  2. Test queries are valid SQL
  3. Idempotent DROP TRIGGER statements
  </verify>
  <done>
  Migration file with comments and test queries added.
  </done>
</task>

</tasks>

<verification>
1. ✅ All 3 increment functions created with atomic jsonb_set pattern
2. ✅ All 3 triggers fire AFTER INSERT on respective tables
3. ✅ Functions use COALESCE to handle NULL values
4. ✅ Message and participant triggers join to events table for organization_id
5. ✅ Triggers are idempotent (DROP IF EXISTS)
6. ✅ Comments in Hebrew and English document each section
7. ✅ Test queries provided for manual verification
</verification>

<success_criteria>
Migration file creates all increment functions and triggers. Each trigger atomically increments the appropriate usage counter when a record is inserted. No race conditions occur under concurrent load.

Ready to deploy to Supabase and test with sample data.
</success_criteria>

<output>
After completion, create `.planning/phases/10-tier-foundation/10-02-SUMMARY.md`
</output>
