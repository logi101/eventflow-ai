/**
 * SeatingPlanView Component
 *
 * תצוגת תכנית שיבוץ לשולחנות
 * Main seating plan view with drag-drop table management
 */

import { useState, useMemo } from 'react'
import {
  DndContext,
  DragOverlay,
  PointerSensor,
  useSensor,
  useSensors,
} from '@dnd-kit/core'
import type { DragEndEvent } from '@dnd-kit/core'
import { TableCard } from './TableCard'
import { generateTableSeating } from '@/modules/networking/services/seatingAlgorithm'
import { saveAllTableAssignments, updateParticipantTable } from '@/modules/networking/services/seatingService'
import type {
  SeatingParticipant,
  SeatingConstraints,
  TableWithParticipants,
} from '@/modules/networking/types'

interface SeatingPlanViewProps {
  eventId: string
  participants: SeatingParticipant[]
  /** מספר שולחנות זמינים */
  numberOfTables: number
  /** קיבולת ברירת מחדל לשולחן */
  defaultTableCapacity?: number
  /** קיבולות משתנות לשולחנות */
  variableCapacities?: Map<number, number>
  /** שולחנות VIP ייעודיים */
  vipTables?: number[]
  /** מפת צבעי מסלולים */
  trackColors?: Map<string, string>
  /** קולבק לאחר שמירה */
  onAssignmentsSaved?: () => void
}

/**
 * רכיב תצוגת תכנית שיבוץ
 */
export function SeatingPlanView({
  eventId,
  participants,
  numberOfTables,
  defaultTableCapacity = 8,
  variableCapacities,
  vipTables = [],
  trackColors,
  onAssignmentsSaved,
}: SeatingPlanViewProps) {
  const [isEditMode, setIsEditMode] = useState(false)
  const [isGenerating, setIsGenerating] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [tables, setTables] = useState<Map<number, SeatingParticipant[]>>(
    new Map()
  )
  const [activeParticipant, setActiveParticipant] = useState<SeatingParticipant | null>(null)

  // Setup drag sensors
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8, // Require 8px movement before drag starts
      },
    })
  )

  // Build table data for rendering
  const tableData: TableWithParticipants[] = useMemo(() => {
    const data: TableWithParticipants[] = []

    for (let i = 1; i <= numberOfTables; i++) {
      const capacity = variableCapacities?.get(i) || defaultTableCapacity
      const participants = tables.get(i) || []
      const isVipTable = vipTables.includes(i)

      data.push({
        tableNumber: i,
        capacity,
        participants,
        isVipTable,
      })
    }

    return data
  }, [tables, numberOfTables, defaultTableCapacity, variableCapacities, vipTables])

  /**
   * יצירת שיבוץ חכם באמצעות האלגוריתם
   */
  const handleGenerateSeating = async () => {
    setIsGenerating(true)
    try {
      const constraints: SeatingConstraints = {
        maxTableSize: defaultTableCapacity,
        variableTableSizes: variableCapacities,
        minSharedInterests: 1,
        maxSameTrack: 4,
        companionsTogether: true,
        vipSpread: true,
        vipPriorityTables: vipTables.length > 0 ? vipTables : undefined,
      }

      const generatedTables = generateTableSeating(participants, constraints)
      setTables(generatedTables)

      // Save to database
      await saveGeneratedAssignments(generatedTables)
    } catch (error) {
      console.error('Failed to generate seating:', error)
      alert('שגיאה ביצירת שיבוץ אוטומטי')
    } finally {
      setIsGenerating(false)
    }
  }

  /**
   * שמירת שיבוצים שנוצרו
   */
  const saveGeneratedAssignments = async (
    generatedTables: Map<number, SeatingParticipant[]>
  ) => {
    setIsSaving(true)
    try {
      const assignments = []

      for (const [tableNumber, tableParticipants] of generatedTables) {
        const isVipTable = vipTables.includes(tableNumber)

        for (const participant of tableParticipants) {
          assignments.push({
            participant_id: participant.id,
            table_number: tableNumber,
            is_vip_table: isVipTable,
            assigned_by: 'ai' as const,
            notes: 'Generated by seating algorithm',
          })
        }
      }

      await saveAllTableAssignments(eventId, assignments)
      onAssignmentsSaved?.()
    } catch (error) {
      console.error('Failed to save assignments:', error)
      alert('שגיאה בשמירת השיבוצים')
    } finally {
      setIsSaving(false)
    }
  }

  /**
   * טיפול בתחילת גרירה
   */
  const handleDragStart = (event: DragEndEvent) => {
    const { active } = event
    const { participantId, sourceTable } = active.data.current as {
      participantId: string
      sourceTable: number
    }

    const sourceParticipants = tables.get(sourceTable) || []
    const participant = sourceParticipants.find((p) => p.id === participantId)

    if (participant) {
      setActiveParticipant(participant)
    }
  }

  /**
   * טיפול בסיום גרירה
   */
  const handleDragEnd = async (event: DragEndEvent) => {
    setActiveParticipant(null)

    const { active, over } = event

    if (!over) return

    const { participantId, sourceTable } = active.data.current as {
      participantId: string
      sourceTable: number
    }
    const targetTableId = over.id as string
    const targetTable = parseInt(targetTableId.replace('table-', ''))

    // Don't do anything if dropped on same table
    if (sourceTable === targetTable) return

    // Check capacity
    const targetTableData = tableData.find((t) => t.tableNumber === targetTable)
    if (targetTableData && targetTableData.participants.length >= targetTableData.capacity) {
      alert('השולחן מלא')
      return
    }

    // Update local state
    const newTables = new Map(tables)
    const sourceParticipants = newTables.get(sourceTable) || []
    const targetParticipants = newTables.get(targetTable) || []

    const participantIndex = sourceParticipants.findIndex((p) => p.id === participantId)
    if (participantIndex === -1) return

    const [participant] = sourceParticipants.splice(participantIndex, 1)
    targetParticipants.push(participant)

    newTables.set(sourceTable, sourceParticipants)
    newTables.set(targetTable, targetParticipants)
    setTables(newTables)

    // Save to database
    try {
      await updateParticipantTable(eventId, participantId, targetTable, 'manager')
      onAssignmentsSaved?.()
    } catch (error) {
      console.error('Failed to update table assignment:', error)
      alert('שגיאה בעדכון שיבוץ')
      // Revert local state on error
      setTables(tables)
    }
  }

  const handleDragCancel = () => {
    setActiveParticipant(null)
  }

  return (
    <div className="space-y-4">
      {/* Header with controls */}
      <div className="flex items-center justify-between bg-white p-4 rounded-lg shadow">
        <h2 className="text-xl font-bold">תכנית שיבוץ לשולחנות</h2>

        <div className="flex items-center gap-3">
          {/* Generate button */}
          <button
            onClick={handleGenerateSeating}
            disabled={isGenerating || isSaving || isEditMode}
            className="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          >
            {isGenerating ? 'מייצר...' : 'יצירת שיבוץ חכם'}
          </button>

          {/* Edit mode toggle */}
          <label className="flex items-center gap-2 cursor-pointer">
            <input
              type="checkbox"
              checked={isEditMode}
              onChange={(e) => setIsEditMode(e.target.checked)}
              className="w-4 h-4 text-purple-600 rounded focus:ring-purple-500"
            />
            <span className="text-sm font-medium">עריכה ידנית</span>
          </label>
        </div>
      </div>

      {/* Seating plan grid */}
      <DndContext
        sensors={sensors}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
        onDragCancel={handleDragCancel}
      >
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {tableData.map((table) => (
            <TableCard
              key={table.tableNumber}
              tableNumber={table.tableNumber}
              capacity={table.capacity}
              participants={table.participants}
              isVipTable={table.isVipTable}
              disabled={!isEditMode}
              trackColors={trackColors}
            />
          ))}
        </div>

        {/* Drag overlay */}
        <DragOverlay>
          {activeParticipant && (
            <div className="bg-white p-3 rounded-lg shadow-xl border-2 border-purple-400">
              <span className="font-medium">
                {activeParticipant.first_name} {activeParticipant.last_name}
              </span>
            </div>
          )}
        </DragOverlay>
      </DndContext>

      {/* Status message */}
      {isSaving && (
        <div className="text-center text-sm text-gray-600">
          שומר שינויים...
        </div>
      )}
    </div>
  )
}
